var documenterSearchIndex = {"docs":
[{"location":"example_model/#Creating-Models-1","page":"Creating Models","title":"Creating Models","text":"","category":"section"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"CurrentModule = ModelConstructors","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"The ModelConstructors.jl provides several two models as well as example scripts that show how to estimate a model.","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"A generic model GenericModel designed as a template for user-defined models and for users who only needs functionality to estimate parameters.\nAn example of a LinearRegression model with minimal fields.","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"To see examples of more complex models, we recommend looking at the source code of models in DSGE.jl. These models use most, if not all, of the fields of GenericModel.","category":"page"},{"location":"example_model/#GenericModel-1","page":"Creating Models","title":"GenericModel","text":"","category":"section"},{"location":"example_model/#Template-for-New-Models-1","page":"Creating Models","title":"Template for New Models","text":"","category":"section"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"The idea of GenericModel is that it should have most fields required to define a generic mathematical model. For most purposes, it will have more fields than needed. If a user wants to create their own model but are not familiar with the process of defining a new model type, then we recommend that the user copy the source code of GenericModel into a new file and editing that file. Referencing the source code of models in DSGE.jl will be useful.","category":"page"},{"location":"example_model/#estim-capm-1","page":"Creating Models","title":"Estimating CAPM","text":"","category":"section"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"Some users only need the ability to estimate parameters. GenericModel provides a convenient way to do that since it includes functionality to choose settings and observables. The script estimatecapm.jl in the examples/factormodel folder in docs shows how to use GenericModel in this way. We can write","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"capm = GenericModel()\ncapm <= parameter(:α, 0., (-1e5, 1e5), (-1e5, 1e5), Untransformed(), Normal(0, 1e3),\n                  fixed = false)\n# add in more parameters...","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"This code instantiates a GenericModel object and adds a parameter called α, which takes a default value of 0. and is assigned a normal prior with mean zero and variance 1000. The two (-1e5, 1e5) intervals specify the bounds of the parameter before and after transformation. The Untransformed() call indicates that we do not transform the parameter, hence why the bounds are the same. For more details on parameters, see the The Parameter type.","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"The example script then constructs a likelihood function. To use SMC.jl, the likelihood function needs to take two arguments: parameters and data. Using GenericModel makes this simple because we just use capm.parameters as the parameters provided as inputs to the likelihood function.","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"Finally, we just call smc(likelihood_fnct, capm.parameters, data) to estimate the parameters of the CAPM model we have defined!","category":"page"},{"location":"example_model/#LinearRegression-1","page":"Creating Models","title":"LinearRegression","text":"","category":"section"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"The LinearRegression type is an example of a model type that does not need to use all the fields provided in GenericModel when estimating. For comparison, the type definition for GenericModel is","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"mutable struct GenericModel{T} <: AbstractModel{T}\n    parameters::ParameterVector{T}\n    steady_state::ParameterVector{T}\n    keys::Dict{Symbol, Int}\n    endogenous_states::Dict{Symbol,Int}\n    exogenous_shocks::Dict{Symbol,Int}\n    observables::Dict{Symbol,Int}\n    pseudo_observables::Dict{Symbol,Int}\n    spec::String\n    subspec::String\n    settings::Dict{Symbol, Setting}\n    test_settings::Dict{Symbol, Setting}\n    rng::MersenneTwister\n    testing::Bool\n    observable_mappings::Dict{Symbol, Observable}\n    pseudo_observable_mappings::Dict{Symbol, PseudoObservable}","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"while the type definition for LinearRegression is only","category":"page"},{"location":"example_model/#","page":"Creating Models","title":"Creating Models","text":"mutable struct LinearRegression{T} <: AbstractModel{T}\n    parameters::ParameterVector{T}\n    keys::Dict{Symbol, Int}\n    spec::String\n    subspec::String\n    settings::Dict{Symbol, Setting}\n    test_settings::Dict{Symbol, Setting}\n    rng::MersenneTwister\n    testing::Bool\nend","category":"page"},{"location":"implementation_details/#Implementation-Details-1","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"CurrentModule = ModelConstructors","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"This section describes important functions and implementation features in greater detail. Additional documentation can also be found in function documentation or in-line.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"This section focuses on what the code does and why. Docstrings and the code itself (including comments) provide detailed information regarding how these basic procedures are implemented.","category":"page"},{"location":"implementation_details/#The-AbstractModel-Type-1","page":"Implementation Details","title":"The AbstractModel Type","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The AbstractModel type provides a common interface for all model objects, which greatly facilitates the implementation of new model specifications. Any concrete subtype of AbstractModel can be passed to any function defined for AbstractModel, provided that the concrete type has the fields that the function expects to be available.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"If a user wants to define a new subclass of models, say regression models, then the user could create a new AbstractRegressionModel type as a subtype of AbstractModel. Functions defined for AbstractRegressionModel would only apply to concrete subtypes of AbstractRegressionModel, but functions defined for AbstractModel will still work on these concrete subtypes.","category":"page"},{"location":"implementation_details/#The-AbstractParameter-Type-1","page":"Implementation Details","title":"The AbstractParameter Type","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The AbstractParameter type implements our notion of a model parameter: a time-invariant, unobserved value that has significance in the model, e.g. for likelihood computation and estimation.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Though all parameters are time-invariant, they can have different features. Some parameters are scaled for use when solving the model[1] and constructing the model's measurement equations[2].","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"During optimization, parameters may be transformed from model space to the real line via one of three different transformations: Untransformed, SquareRoot, and Exponential. These transformations are also defined as types, and require additional information for each parameter. Typically, we have two \"hyperparameters\" for these transformations, a, and b.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Untransformed: a and b do nothing\nSquareRoot: a and b specify the bounds the parameter takes, i.e. xin (a b)\nExponential: a and b are the parameters in the transformation a + exp(x - b)","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"In some models, steady state values might be relevant parameters. They are typically functions of other parameters, so they do not need to be estimated directly.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"While parameters are \"time-invariant\", we do allow regime switching. As an example, suppose that we have a linear regression with data from time periods t = 1dots T, where T  4, and in t = 3, the intercept of the regression is assumed to change values because of a structural break in the time series. We can model the intercept as a parameter with regime-switching. The parameter has one value in periods t = 1 2 and a different value in periods t = 3dots T. Currently, only regime-switching in the values of the parameter has been tested, but we have implemented regime switching in all the features. For example, you may want a different prior in each regime. See Regime-Switching Interface for documentation on the interface for regime-switching parameters.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The various requirements on parameters are nicely addressed using a parameterized type hierarchy.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"AbstractParameter{T<:Number}: The common abstract supertype for all parameters.\nParameter{T<:Number, U<:Transform}: The abstract supertype for parameters that are directly estimated.\nUnscaledParameter{T<:Number, U:<Transform}: Concrete type for parameters that do not need to be scaled for equilibrium conditions.\nScaledParameter{T<:Number, U:<Transform}: Concrete type for parameters that are scaled for equilibrium conditions.\nSteadyStateParameter{T<:Number}: Concrete type for steady-state parameters.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"All Parameters have the fields defined in UnscaledParameter:","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"UnscaledParameter","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"ScaledParameters also have the following fields:","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"scaledvalue::T: Parameter value scaled for use in eqcond.jl\nscaling::Function: Function used to scale parameter value for use in equilibrium conditions.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Note: Though not strictly necessary, defining a scaling with the parameter object allows for much a much cleaner definition of the equilibrium conditions.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Because the values of SteadyStateParameters are directly computed as a function of ScaledParameters and UnscaledParameters, they only require 4 fields:","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"SteadyStateParameter","category":"page"},{"location":"implementation_details/#ModelConstructors.SteadyStateParameter","page":"Implementation Details","title":"ModelConstructors.SteadyStateParameter","text":"SteadyStateParameter{T} <: AbstractParameter{T}\n\nSteady-state model parameter whose value depends upon the value of other (non-steady-state) Parameters. SteadyStateParameters must be constructed and added to an instance of a model object m after all other model Parameters have been defined. Once added to m, SteadyStateParameters are stored in m.steady_state. Their values are calculated and set by steadystate!(m), rather than being estimated directly. SteadyStateParameters do not require transformations from the model space to the real line or scalings for use in equilibrium conditions.\n\nFields\n\nkey::Symbol: Parameter name. Should conform to the guidelines established in the DSGE Style Guide.\nvalue::T: The parameter's steady-state value.\ndescription::String: Short description of the parameter's economic significance.\ntex_label::String: String for printing parameter name to LaTeX.\n\n\n\n\n\n","category":"type"},{"location":"implementation_details/#The-Observable-and-PseudoObservable-Types-1","page":"Implementation Details","title":"The Observable and PseudoObservable Types","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"We similarly encapsulate information about observables and pseudo-observables (unobserved linear combinations of states, e.g. the output gap) into the Observable and PseudoObservable types. Each type has identifier fields key, name, and longname.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Most importantly, both Observables and PseudoObservables include the information needed for transformations to and from model units. For Observables, these are the input_series, fwd_transform, and rev_transform fields. \"Forward transformations\" are applied to transform the raw input data series specified in input_series to model units. The model is estimated and forecasted in model units, and then we apply \"reverse transformations\" to get human-readable units before computing means and bands or plotting. Pseudo-observables are not observed, so they do not have input_series or fwd_transforms, but they may however have rev_transforms.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"As an example, the :obs_gdp Observable uses as input_series aggregate nominal GDP in levels, the GDP price index, and population in levels, all from FRED.[3] These series are fwd_transformed to get quarter-over-quarter log growth rates of per-capita real GDP, which are the Observable's model units. The reverse transformation then converts :obs_gdp into annualized quarter-over-quarter percent changes of aggregate real GDP.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Observable\nPseudoObservable","category":"page"},{"location":"implementation_details/#ModelConstructors.Observable","page":"Implementation Details","title":"ModelConstructors.Observable","text":"mutable struct Observable\n\nFields\n\nkey::Symbol\ninput_series::Vector{Symbol}: vector of mnemonics, each in the form :MNEMONIC__SOURCE (e.g. :GDP__FRED). This vector is parsed to determine source (e.g. per-capita consumption gets population and consumption).\nfwd_transform::Function: Extracts appropriate input_series from a DataFrame of levels, and transforms data to model units (for example, computes per-capita growth rates from levels).\nrev_transform::Function: Transforms a series from model units into observable units. May take kwargs.\nname::String: e.g. \"Real GDP growth\"\nlongname::String: e.g. \"Real GDP growth per capita\"\n\n\n\n\n\n","category":"type"},{"location":"implementation_details/#ModelConstructors.PseudoObservable","page":"Implementation Details","title":"ModelConstructors.PseudoObservable","text":"mutable struct PseudoObservable\n\nFields\n\nkey::Symbol\nname::String: e.g. \"Flexible Output Growth\"\nlongname::String: e.g. \"Output that would prevail in a flexible-price economy\"\nrev_transform::Function: Transforms a series from model units into observable units. May take kwargs.\n\n\n\n\n\n","category":"type"},{"location":"implementation_details/#Model-Settings-1","page":"Implementation Details","title":"Model Settings","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The Setting type implements computational settings that affect how the code runs without affecting the mathematical definition of the model. Depending on the model, these may include flags (e.g. whether or not to recompute the Hessian), parameterization for the Metropolis-Hastings algorithm (e.g. number of times to draw from the posterior distribution), and the vintage of data being used (Setting is a parametric type - a Setting{T<:Any}, so Booleans, Numbers, and Strings can all be turned into Settings). If settings exist for a model type, then they should be stored centrally in the settings dictionary within the model object.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Why implement a Setting type when we could put their values directly into the source code or dictionary? The most obvious answer is that the parametric type allows us to implement a single interface for all Settings (Booleans, Strings, etc.), so that when we access a particular setting during the estimation and forecast steps, we don't have to think about the setting's type.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Settings play an important role in addition to providing useful abstraction. Estimating and forecasting the New York Fed DSGE model takes many hours of computation time and creates a lot of output files. It is useful to be able to compare model output from two different models whose settings differ slightly (for example, consider two identical models that use different vintages of data as input). A central feature of the Setting type is a mechanism that generates unique, meaningful filenames when code is executed with different settings. Specifically, when a setting takes on a non-default value, a user-defined setting code (along with the setting's value) are appended to all output files generated during execution.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The Setting{T<:Any} type is defined as follows:","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Setting","category":"page"},{"location":"implementation_details/#ModelConstructors.Setting","page":"Implementation Details","title":"ModelConstructors.Setting","text":"Setting{T}\n\nThe Setting type is an interface for computational settings that affect how the code runs without affecting the mathematical definition of the model. It also provides support for non-conflicting file names for output of 2 models that differ only in the values of their computational settings.\n\nFields\n\nkey::Symbol: Name of setting\nvalue::T: Value of setting\nprint::Bool: Indicates whether to append this setting's code and value to output file names. If true, output file names will include a suffix of the form _code1=val1_code2=val2 etc. where codes are listed in alphabetical order.\ncode::String: string to print to output file suffixes when print=true.\ndescription::String: Short description of what the setting is used for.\n\n\n\n\n\n","category":"type"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"We provide two functions default_settings! and default_test_settings! to initialize settings that most models can have. The settings are","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"save root\ninput data root\nvintage of data to be used\ndataset id","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"To update the value of an existing function, the user has two options. First, the user may use the <= syntax. However, for this to work properly, it is essential that the setting's key field be exactly the same as that of an existing entry in m.settings. Otherwise, an additional entry will be added to m.settings and the old setting will be the one accessed from other all routines. A potentially safer, though clunkier, option is to use the update! method.","category":"page"},{"location":"implementation_details/#Type-Interfaces-1","page":"Implementation Details","title":"Type Interfaces","text":"","category":"section"},{"location":"implementation_details/#Parameter-Interface-1","page":"Implementation Details","title":"Parameter Interface","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Modules = [ModelConstructors]\nPages = [\"parameters.jl\"]\nOrder = [:function]","category":"page"},{"location":"implementation_details/#Base.rand-Tuple{Array{AbstractParameter{Float64},1},Int64}","page":"Implementation Details","title":"Base.rand","text":"Distributions.rand(p::Vector{AbstractParameter{Float64}}, n::Int;\n    regime_switching::Bool = false, toggle::Bool = true)\n\nGenerate n draws from the priors of each parameter in p.This returns a matrix of size (length(p),n), where each column is a sample. To sample from p when it has regime-switching, set regime_switching =  true. The toggle keyword is only relevant for regime-switching sampling. Please see ?ModelConstructors.rand_regime_switching.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#Base.rand-Tuple{Array{AbstractParameter{Float64},1}}","page":"Implementation Details","title":"Base.rand","text":"Distributions.rand(p::Vector{AbstractParameter{Float64}}; regime_switching::Bool = false,\n    toggle::Bool = true)\n\nGenerate a draw from the prior of each parameter in p.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.differentiate_transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var\"#s101\",Untransformed} where var\"#s101\"<:Number,S}} where S","page":"Implementation Details","title":"ModelConstructors.differentiate_transform_to_model_space","text":"differentiate_transform_to_model_space{S<:Real,T<:Number, U<:Transform}(p::Parameter{S,T,U}, x::S)\n\nDifferentiates the transform of x from the real line to lie between p.valuebounds The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):\n\nUntransformed: x\nSquareRoot:    (a+b)/2 + (b-a)/2 * c * x/sqrt(1 + c^2 * x^2)\nExponential:   a + exp(c*(x-b))\n\nTheir gradients are therefore\n\nUntransformed: 1\nSquareRoot:    (b-a)/2 * c / (1 + c^2 * x^2)^(3/2)\nExponential:   c * exp(c*(x-b))\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.differentiate_transform_to_real_line-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var\"#s101\",Untransformed} where var\"#s101\"<:Number,S}} where S","page":"Implementation Details","title":"ModelConstructors.differentiate_transform_to_real_line","text":"differentiate_transform_to_real_line{S<:Real,T<:Number, U<:Transform}(p::Parameter{S,T,U}, x::S)\n\nDifferentiates the transform of x from the model space lying between p.valuebounds to the real line. The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):\n\nUntransformed: x\nSquareRoot:   (1/c)*cx/sqrt(1 - cx^2), where cx =  2 * (x - (a+b)/2)/(b-a)\nExponential:   b + (1 / c) * log(x-a)\n\nTheir gradients are therefore\n\nUntransformed: 1\nSquareRoot:    (1/c) * (1 / ( 1 - cx^2)^(-3/2)) * (2/(b-a))\nExponential:   1 / (c * (x - a))\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.moments-Tuple{Parameter}","page":"Implementation Details","title":"ModelConstructors.moments","text":"moments(θ::Parameter)\n\nIf θ's prior is a RootInverseGamma, τ and ν. Otherwise, returns the mean and standard deviation of the prior. If θ is fixed, returns (θ.value, 0.0).\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.n_parameters_regime_switching-Tuple{Array{AbstractParameter{T},1} where T}","page":"Implementation Details","title":"ModelConstructors.n_parameters_regime_switching","text":"function n_parameters_regime_switching(p::ParameterVector)\n\ncalculates the total number of parameters in p across all regimes.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{ScaledParameter{T,U},T}} where U<:Transform where T<:Number","page":"Implementation Details","title":"ModelConstructors.parameter","text":"parameter(p::ScaledParameter{S,T,U}, newvalue::S) where {S<:Real, T<:Number,U<:Transform}\n\nReturns a ScaledParameter with value field equal to newvalue and scaledvalue field equal to p.scaling(newvalue). If p is a fixed parameter, it is returned unchanged.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{UnscaledParameter{T,U},T}} where U<:Transform where T<:Number","page":"Implementation Details","title":"ModelConstructors.parameter","text":"parameter(p::UnscaledParameter{S,T,U}, newvalue::S) where {S<:Real,T<:Number,U<:Transform}\n\nReturns an UnscaledParameter with value field equal to newvalue. If p is a fixed parameter, it is returned unchanged.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{V}, Tuple{Symbol,Union{T, V}}, Tuple{Symbol,Union{T, V},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U,Union{Distributions.Distribution{Distributions.Multivariate,Distributions.Continuous}, Distributions.Distribution{Distributions.Univariate,Distributions.Continuous}, Nullables.Nullable{Distributions.Distribution{Distributions.Multivariate,Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.Univariate,Distributions.Continuous}}}}} where U<:Transform where T<:Real where V<:(Array{T,1} where T)","page":"Implementation Details","title":"ModelConstructors.parameter","text":"parameter{S,T,U<:Transform}(key::Symbol, value::S, valuebounds = (value,value),\n                          transform_parameterization = (value,value),\n                          transform = Untransformed(), prior = NullablePrior();\n                          fixed = true, scaling::Function = identity, description = \"\",\n                          tex_label::String = \"\")\n\nBy default, returns a fixed UnscaledParameter object with key key and value value. If scaling is given, a ScaledParameter object is returned.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var\"#s101\",Untransformed} where var\"#s101\"<:Number,S}} where S","page":"Implementation Details","title":"ModelConstructors.transform_to_model_space","text":"transform_to_model_space{S<:Real,T<:Number, U<:Transform}(p::Parameter{S,T,U}, x::S)\n\nTransforms x from the real line to lie between p.valuebounds without updating p.value. The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):\n\nUntransformed: x\nSquareRoot:    (a+b)/2 + (b-a)/2 * c * x/sqrt(1 + c^2 * x^2)\nExponential:   a + exp(c*(x-b))\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.transform_to_real_line-Union{Tuple{ModelConstructors.ParameterAD{S,var\"#s100\",Untransformed} where var\"#s100\"<:Number}, Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var\"#s99\",Untransformed} where var\"#s99\"<:Number,S}} where S","page":"Implementation Details","title":"ModelConstructors.transform_to_real_line","text":"transform_to_real_line(p::Parameter{S,T,U}, x::S = p.value) where {S<:Real, T<:Number, U<:Transform}\n\nTransforms p.value from model space (between p.valuebounds) to the real line, without updating p.value. The transformations are defined as follows, where (a,b) = p.transform_parameterization, c a scalar (default=1), and x = p.value:\n\nUntransformed: x\nSquareRoot:   (1/c)*cx/sqrt(1 - cx^2), where cx =  2 * (x - (a+b)/2)/(b-a)\nExponential:   b + (1 / c) * log(x-a)\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.update!-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1},BitArray{1}}} where S","page":"Implementation Details","title":"ModelConstructors.update!","text":"update!(pvec::ParameterVector, values::Vector{S},\n    indices::BitArray{1}; change_value_type::Bool = false) where S\n\nUpdates a subset of parameters in pvec specified by indices. Assumes values is sorted in the same order as the parameters in pvec, ignoring parameters that are to be left unchanged.\n\nHowever, update! will not overwrite fixed parameters, even if indices has a true in an index corresponding to a fixed parameter.\n\nExamples\n\njulia> pvec = ParameterVector{Float64}(undef, 3);\njulia> pvec[1] = parameter(:a, 1., (0., 3.), (0., 3.), fixed = false);\njulia> pvec[2] = parameter(:b, 1.);\njulia> pvec[3] = parameter(:c, 1., (0., 3.), (0., 3.), fixed = false);\njulia> values = [2., 2.];\njulia> update!(pvec, values, [true, false, true]);\njulia> map(x -> x.value, pvec)\n3-element Array{Float64,1}:\n 2.0\n 1.0\n 2.0\n\n\njulia> pvec = ParameterVector{Float64}(undef, 3);\njulia> pvec[1] = parameter(:a, 1.);\njulia> pvec[2] = parameter(:b, 1.);\njulia> pvec[3] = parameter(:c, 1.);\njulia> values = [2., 2.];\njulia> update!(pvec, values, [true, false, true]);\njulia> map(x -> x.value, pvec)\n3-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.update!-Union{Tuple{T}, Tuple{Array{AbstractParameter{T},1} where T,Array{T,1}}} where T","page":"Implementation Details","title":"ModelConstructors.update!","text":"update!(pvec::ParameterVector, values::Vector{S}; change_value_type::Bool = false) where S\n\nUpdate all parameters in pvec that are not fixed with values. Length of values must equal length of pvec. Function optimized for speed.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.update-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,Array{S,1}}} where S","page":"Implementation Details","title":"ModelConstructors.update","text":"update(pvec::ParameterVector, values::Vector{S}) where S\n\nReturns a copy of pvec where non-fixed parameter values are updated to values. pvec remains unchanged. Length of values must equal length of pvec.\n\nWe define the non-mutating version like this because we need the type stability of map!\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.parameters2namedtuple-Union{Tuple{AbstractArray{S,1}}, Tuple{S}} where S<:AbstractParameter","page":"Implementation Details","title":"ModelConstructors.parameters2namedtuple","text":"parameters2namedtuple(m)\n\nreturns the parameters of m as a NamedTuple. The input m can be either an AbstractVector{<: AbstractParameter} or an AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.rand_regime_switching-Tuple{Array{AbstractParameter{Float64},1}}","page":"Implementation Details","title":"ModelConstructors.rand_regime_switching","text":"rand_regime_switching(p::Vector{AbstractParameter{Float64}}; toggle::Bool = true)\n\nGenerate a draw from the prior of each parameter in p.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#Regime-Switching-Interface-1","page":"Implementation Details","title":"Regime-Switching Interface","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"To implement regime-switching, we add a field to Parameter types called regimes::Dict{Symbol, OrderedDict{Int, Any}}. The keys of the top level dictionary are the names of the other fields in a Parameter type, e.g. :value. Each key then points to an OrderedDict, whose keys are the numbers of different regimes and values are the corresponding values for each regime.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"The field regimes functions as a \"storage\" of information. When a Parameter type interacts with another object in Julia, e.g. p + 1., where p is a Parameter, what actually happens is p.value + 1.. Only the current fields of p will be used when interacting with other objects. To use a different value (or different fields) from another regime, the user needs to tell the parameter to switch regimes the toggle_regime! function (see below).","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"By default, the regimes field is empty (see the documentation of the parameter function in Parameter Interface). To add values, either pass in the dictionary as a keyword to parameter or use set_regime_val!. Note that the latter function is not exported.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Note that regimes must be sorted in order because we store the regimes as an OrderedDict, and OrderedDict objects are sorted by insertion order.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Modules = [ModelConstructors]\nPages = [\"regimes.jl\"]\nOrder = [:function]","category":"page"},{"location":"implementation_details/#ModelConstructors.regime_fixed-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.regime_fixed","text":"regime_fixed(p::Parameter{S}, i::Int) where S <: Real\nregime_fixed(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\n\nreturns whether p is fixed in regime i for the first method and whether true p is fixed in regime d[model_regime] for the second method.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.regime_prior-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.regime_prior","text":"regime_prior(p::Parameter{S}, i::Int) where S <: Real\nregime_prior(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\n\nreturns the prior of p in regime i for the first method and the prior of p in regime d[model_regime] for the second.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.regime_val-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.regime_val","text":"regime_val(p::Parameter{S}, i::Int) where S <: Real\nregime_val(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\n\nreturns the value of p in regime i for the first method and the value of p in regime d[model_regime for the second.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.regime_valuebounds-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.regime_valuebounds","text":"regime_valuebounds(p::Parameter{S}, i::Int) where S <: Real\nregime_valuebounds(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\n\nreturns the valuebounds of p  in regime i for the first method and the valuebounds of p in regime d[model_regime] for the second method.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.set_regime_fixed!-Union{Tuple{S1}, Tuple{S}, Tuple{Parameter{S1,U} where U<:Transform,Int64,S}} where S1<:Real where S<:Bool","page":"Implementation Details","title":"ModelConstructors.set_regime_fixed!","text":"set_regime_fixed!(p::Parameter{S}, i::Int, v::S; update_valuebounds::Interval = (NaN, NaN))\n\nsets whether p is fixed in regime i of p. Set update_valuebounds to true to set the valuebounds to match the fixed value.\n\nThe second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary d maps each \"model\" regime to a \"parameter\" regime. In this way, the second method specifies which \"parameter\" regime should be used at a given \"model\" regime.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.set_regime_prior!-Union{Tuple{S}, Tuple{Parameter,Int64,S}} where S<:Union{Nullables.Nullable{Distributions.Distribution{Distributions.Multivariate,Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.Univariate,Distributions.Continuous}}}","page":"Implementation Details","title":"ModelConstructors.set_regime_prior!","text":"set_regime_prior!(p::Parameter{S}, i::Int, v)\nset_regime_prior!(p::Parameter{S}, model_regime::Int, v, d::AbstractDict{Int, Int})\n\nsets the prior in regime i of p to be v. The type of v can be a NullablePriorUnivariate, NullablePriorMultivariate, ContinuousUnivariateDistribution, or `ContinuousMultivariateDistribution'.\n\nThe second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary d maps each \"model\" regime to a \"parameter\" regime. In this way, the second method specifies which \"parameter\" regime should be used at a given \"model\" regime.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.set_regime_val!-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64,S}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.set_regime_val!","text":" set_regime_val!(p::Parameter{S},\n    i::Int, v::S; override_bounds::Bool = false) where S <: Real\n set_regime_val!(p::Parameter{S},\n    model_regime::Int, v::S, d::AbstractDict{Int, Int}; override_bounds::Bool = false) where S <: Real\n\nsets the value in regime i of p to be v. By default, we enforce the bounds that are currently in p, but the bounds can be ignoerd by setting override_bounds = true.\n\nThe second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary d maps each \"model\" regime to a \"parameter\" regime. In this way, the second method specifies which \"parameter\" regime should be used at a given \"model\" regime.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.set_regime_valuebounds!-Union{Tuple{S}, Tuple{Parameter,Int64,Tuple{S,S}}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.set_regime_valuebounds!","text":"set_regime_valuebounds!(p::Parameter{S}, i::Int, v::S)\n\nsets valuebounds for p in regime i to v.\n\nThe second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary d maps each \"model\" regime to a \"parameter\" regime. In this way, the second method specifies which \"parameter\" regime should be used at a given \"model\" regime.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.toggle_regime!-Union{Tuple{S}, Tuple{Parameter{S,U} where U<:Transform,Int64}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.toggle_regime!","text":"toggle_regime!(p::Parameter{S}, i::Int) where S <: Real\ntoggle_regime!(pvec::ParameterVector{S}, i::Int) where S <: Real\ntoggle_regime!(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\ntoggle_regime!(pvec::ParameterVector{S}, model_regime::Int, d::AbstractDict{Symbol, <: AbstractDict{Int, Int}}) where S <: Real\ntoggle_regime!(pvec::ParameterVector{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S <: Real\n\nchanges the fields of p to regime i.\n\nFor example, if\n\np.regimes[:value] = OrderedDict{Int, Any}(1 => 1, 2 => 3)\n\nthen toggle_regime!(p, 1) will cause p.value = 1 and toggle_regime!(p, 2) will cause p.value = 3.\n\nThe third method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary d maps each \"model\" regime to a \"parameter\" regime. In this way, the second method specifies which \"parameter\" regime should be used at a given \"model\" regime.\n\nThe fourth method extends the third to a ParameterVector, with the possibility that each parameter may have different mappings to the model regimes. Each key of d corresponds to the key of a parameter, and each value of d is the mapping for model regimes to the parameter regimes of p.key. The fifth method is similar to the fourth but assumes any regime-switching parameter has the same mapping from model regimes to parameter regimes, hence the use of a common dictionary.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.get_values-Union{Tuple{Array{AbstractParameter{S},1}}, Tuple{S}} where S<:Real","page":"Implementation Details","title":"ModelConstructors.get_values","text":"get_values(pvec::ParameterVector{S}; regime_switching::Bool = true) where {S <: Real}\n\nconstructs a vector of the underlying values in a ParameterVector, including if there are regime-switching values.\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#Setting-Interface-1","page":"Implementation Details","title":"Setting Interface","text":"","category":"section"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"Modules = [ModelConstructors]\nPages = [\"settings.jl\"]\nOrder = [:function]","category":"page"},{"location":"implementation_details/#Base.:<=-Tuple{AbstractModel,Setting}","page":"Implementation Details","title":"Base.:<=","text":"(<=)(m::AbstractModel, s::Setting)\n\nSyntax for adding a setting to a model/overwriting a setting via m <= Setting(...)\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.get_setting-Tuple{AbstractModel,Symbol}","page":"Implementation Details","title":"ModelConstructors.get_setting","text":"get_setting(m::AbstractModel, setting::Symbol)\n\nReturns the value of the setting\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#ModelConstructors.update!-Tuple{Setting,Setting}","page":"Implementation Details","title":"ModelConstructors.update!","text":"update!(a::Setting, b::Setting)\n\nUpdate a with the fields of b if:\n\nThe key field is updated if a.key == b.key\nThe print boolean and code string are overwritten if a.print is false and b.print is true, or a.print is true, b.print is false, and b.code is non-empty.\nThe description field is updated if b.description is nonempty\n\n\n\n\n\n","category":"method"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"rng::MersenneTwister\ntesting::Bool\nobservable_mappings::Dict{Symbol, Observable}\npseudo_observable_mappings::Dict{Symbol, PseudoObservable}","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"[1]: By solving the model, we mean a mapping from parameters to        some objects of interest. In a state space model,        solving the model is a mapping from parameters        to a state transition function. By constructing","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"[2]: In the context of a state space model,         a measurement equation is mapping from states to observable data.","category":"page"},{"location":"implementation_details/#","page":"Implementation Details","title":"Implementation Details","text":"[3]: In DSGE.jl, we implement a          load_data function that parses input_series to retrieve data          from FRED. To take full advantage of the Observable type, users may          want to write their own load_data function. For example, it may          be convenient to write a load_data function that parses input_series          to select column(s) from saved CSV files and combines them into          a single data frame.","category":"page"},{"location":"license/#License-1","page":"License","title":"License","text":"","category":"section"},{"location":"license/#","page":"License","title":"License","text":"Copyright (c) 2019, Federal Reserve Bank of New York All rights reserved.","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Redistributions of source code must retain the above copyright notice, this list of","category":"page"},{"location":"license/#","page":"License","title":"License","text":"conditions and the following disclaimer.","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Redistributions in binary form must reproduce the above copyright notice, this list of","category":"page"},{"location":"license/#","page":"License","title":"License","text":"conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Neither the name of the copyright holder nor the names of its contributors may be used to","category":"page"},{"location":"license/#","page":"License","title":"License","text":"endorse or promote products derived from this software without specific prior written permission.","category":"page"},{"location":"license/#","page":"License","title":"License","text":"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"contributing/#contributing-1","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"","category":"section"},{"location":"contributing/#Notes-for-ModelConstructors.jl-Contributors-1","page":"Contributing to ModelConstructors.jl","title":"Notes for ModelConstructors.jl Contributors","text":"","category":"section"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"We may add more features to this package as new use cases emerge.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"As these steps are under development, we would welcome improvements to the existing code from the community. Some examples could be:","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Performance improvements\nFeatures of certain models that our code cannot implement\nExpanding the regime switching functionality of Parameter types.\nOther general improvements\nAdding documentation/test coverage\nAdding existing notable models into the docs/examples directory.","category":"page"},{"location":"contributing/#Git-Recommendations-For-Pull-Requests-1","page":"Contributing to ModelConstructors.jl","title":"Git Recommendations For Pull Requests","text":"","category":"section"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"These are adapted from JuliaLang.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Avoid working from the main branch of your fork, creating a new branch will make it easier if ModelConstructor's main changes and you need to update your pull request.\nTry to squash together small commits that make repeated changes to the same section of code so your pull request is easier to review, and Julia's history won't have any broken intermediate commits. A reasonable number of separate well-factored commits is fine, especially for larger changes.\nIf any conflicts arise due to changes in ModelConstructors's main, prefer updating your pull request branch with git rebase versus git merge or git pull, since the latter will introduce merge commits that clutter the git history with noise that makes your changes more difficult to review.\nDescriptive commit messages are good.\nUsing git add -p or git add -i can be useful to avoid accidentally committing unrelated changes.\nGitHub does not send notifications when you push a new commit to a pull request, so please add a comment to the pull request thread to let reviewers know when you've made changes.\nWhen linking to specific lines of code in discussion of an issue or pull request, hit the y key while viewing code on GitHub to reload the page with a URL that includes the specific version that you're viewing. That way any lines of code that you refer to will still make sense in the future, even if the content of the file changes.\nWhitespace can be automatically removed from existing commits with git rebase.\nTo remove whitespace for the previous commit, run git rebase --whitespace=fix HEAD~1.\nTo remove whitespace relative to the main branch, run git rebase --whitespace=fix main.","category":"page"},{"location":"contributing/#ModelConstructors-Julia-Style-Guide-1","page":"Contributing to ModelConstructors.jl","title":"ModelConstructors Julia Style Guide","text":"","category":"section"},{"location":"contributing/#Intro-1","page":"Contributing to ModelConstructors.jl","title":"Intro","text":"","category":"section"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"This document lists Julia coding recommendations consistent with best practices in the software development community. The recommendations are based on guidelines for other languages collected from a number of sources and on personal experience. These guidelines are written with the New York Fed DSGE code in mind. All pull requests submitted should follow these general style guidelines.","category":"page"},{"location":"contributing/#Naming-conventions-1","page":"Contributing to ModelConstructors.jl","title":"Naming conventions","text":"","category":"section"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Emphasize readability! Our goal is for the code to mimic the mathematical notation used in New York Fed DSGE papers as closely as possible.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"The names of variables should document their meaning or","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"use. Variables with a large scope should have especially meaningful names. Variables with a small scope can have short names.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Exhibit consistency with the existing codebase.\nModules and type names in UpperCamelCase\nVariable names in snake_case.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Variable names should be in lower case, using underscores to separate parts of a compound variable name. For example, steady_state and equilibrium_conditions are two fields in the Model990() object that follow this convention. Also notice that, though the words could be shortened, they are spelled out for maximum clarity.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"The prefix n_ should be used for variables representing the","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"number of objects (e.g. n_parameters or n_anticipated_shocks) use the suffix s as is natural in spoken language.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Negative Boolean variable names should be avoided. A problem arises","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"when such a name is used in conjunction with the logical negation operator as this results in a double negative. It is not immediately apparent what !isNotFound means.  Use isFound. Avoid isNotFound.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Named constants can be all uppercase using underscore to separate words:","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"MAX_ITERATIONS","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Naming mathematical objects","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Variables with mathematical significance should use unicode characters and imitate LaTeX syntax.  For example, ρ should be used to name the autocorrelation coefficient in an AR(1) process, and σ should be used to name standard deviation. Parameters in the text should keep the same symbol in the code (e.g. α in the code is the same α as in this paper, and takes on it usual significance as the capital share in a Cobb-Douglas output function.","category":"page"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"General conventions\nUnderscores can and should be used when the variable refers to a mathematical object that has a subscript. (In this case, we are imitating LaTeX syntax.) For example, r_m in LaTeX should be represented by the variable r_m.\nIf the mathematical object has multiple subscripts, for example x_ij, simply concatenate the subscripts: x_ij.\nIf the object has superscripts as well as subscripts, for example y^f_t, separate the superscripts with an underscore and place them first: y_f_t.\nFor compatibility with existing code, variables with numeric subscripts should exclude the underscore: G0, ψ1.\nMatrices that have mathematical significance (e.g. the matrices of the transition and measurement equations) should be upper case, as they are in mathematical notation, and can repeat the letter to avoid collisions: TTT or QQ.\nSymbols such as overbars (which indicate mean values) and  tildes (which indicate log-deviations from the steady state) are written using a 3- or 4-letter abbreviation immediately after the variable they modify: kbar_t, ztil (z tilde).\nStars indicating steady-state variables are included as subscripts: π_star_t\nSuffixes\nTime: Consistent with the previous bullet points, the suffix _t as in x_t signifies the value of x at time t. The suffix _t1 signifies the value of x at time t-1.\nShocks: The suffix _sh refers to a model shock.\nPrefixes\nThe prefix eq_ refers to an equilibrium condition.\nThe prefix obs_ refers to an observable.\nThe prefix E refers to the expectation operator.\nThe prefix I refers to the indicator operator.\nObservables with the prefix g refer to growth rates.","category":"page"},{"location":"contributing/#Code-Formatting-Guidelines-1","page":"Contributing to ModelConstructors.jl","title":"Code Formatting Guidelines","text":"","category":"section"},{"location":"contributing/#","page":"Contributing to ModelConstructors.jl","title":"Contributing to ModelConstructors.jl","text":"Indent 4 spaces\nWrap lines at 92 characters\nUse whitespace to enhance readability\nNo trailing whitespace","category":"page"},{"location":"#ModelConstructors-1","page":"Home","title":"ModelConstructors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = ModelConstructors","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ModelConstructors.jl package implements a generic mathematical model object. A model of any type can be defined as long as it has parameters. Moreover, this package contains the building blocks of model objects used for both Dynamic Stochastic General Equilibrium models (DSGE.jl) and Sequential Monte Carlo (SMC.jl). The Parameter, Observable, Setting, State, etc. types are included.","category":"page"},{"location":"#Table-of-Contents-1","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"model_design.md\",\n  \"example_model.md\",\n  \"implementation_details.md\",\n  \"contributing.md\",\n  \"license.md\"\n]","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Developers of this package at the New York Fed include","category":"page"},{"location":"#","page":"Home","title":"Home","text":"William Chen\nShlok Goyal\nAlissa Johnson\nEthan Matlin\nReca Sarfati","category":"page"},{"location":"model_design/#Model-Design-1","page":"Model Design","title":"Model Design","text":"","category":"section"},{"location":"model_design/#","page":"Model Design","title":"Model Design","text":"ModelConstructors.jl is an object-oriented approach to working with mathematical models. This approach takes advantage of Julia's type system, multiple dispatch, package-handling mechanism, and other features. A single model object centralizes  all information about the model's parameters, states, equilibrium conditions, and settings in a single data structure. The model object also keeps track of file locations for all I/O operations.","category":"page"},{"location":"model_design/#","page":"Model Design","title":"Model Design","text":"The most minimal model only needs to have parameters, but a generic model may have one or more of the following objects:","category":"page"},{"location":"model_design/#","page":"Model Design","title":"Model Design","text":"Parameters: Have values, bounds, fixed-or-not status, priors, and regime switching. An instance of the AbstractParameter type houses all information about a given parameter in a single data structure. See The AbstractParameter Type.\nSettings: Provide a general way to choose settings that affect how a model is manipulated. See The Setting Type.\nObservables and Pseudo-Observables: Mapping of names to indices, as well as information necessary for transformations. See The Observable and PseudoObservable Types.","category":"page"},{"location":"model_design/#","page":"Model Design","title":"Model Design","text":"These are enough to define a generic model. Everything else is essentially a function of these basics. For example, estimating a model requires two more steps: defining likelihood function and selecting an estimation routine. See Estimating CAPM for an example estimation using SMC.","category":"page"}]
}
