<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation Details · ModelConstructors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ModelConstructors.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../model_design/">Model Design</a></li><li><a class="tocitem" href="../example_model/">Creating Models</a></li><li class="is-active"><a class="tocitem" href>Implementation Details</a><ul class="internal"><li><a class="tocitem" href="#The-AbstractModel-Type-1"><span>The <code>AbstractModel</code> Type</span></a></li><li><a class="tocitem" href="#The-AbstractParameter-Type-1"><span>The <code>AbstractParameter</code> Type</span></a></li><li><a class="tocitem" href="#The-Observable-and-PseudoObservable-Types-1"><span>The <code>Observable</code> and <code>PseudoObservable</code> Types</span></a></li><li><a class="tocitem" href="#Model-Settings-1"><span>Model Settings</span></a></li><li><a class="tocitem" href="#Type-Interfaces-1"><span>Type Interfaces</span></a></li></ul></li><li><a class="tocitem" href="../regime_switching/">Regime-Switching Parameters</a></li><li><a class="tocitem" href="../contributing/">Contributing to ModelConstructors.jl</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation Details</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/master/docs/src/implementation_details.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation-Details-1"><a class="docs-heading-anchor" href="#Implementation-Details-1">Implementation Details</a><a class="docs-heading-anchor-permalink" href="#Implementation-Details-1" title="Permalink"></a></h1><p>This section describes important functions and implementation features in greater detail. Additional documentation can also be found in function documentation or in-line.</p><p>This section focuses on what the code does and why. Docstrings and the code itself (including comments) provide detailed information regarding <em>how</em> these basic procedures are implemented.</p><h2 id="The-AbstractModel-Type-1"><a class="docs-heading-anchor" href="#The-AbstractModel-Type-1">The <code>AbstractModel</code> Type</a><a class="docs-heading-anchor-permalink" href="#The-AbstractModel-Type-1" title="Permalink"></a></h2><p>The <code>AbstractModel</code> type provides a common interface for all model objects, which greatly facilitates the implementation of new model specifications. Any concrete subtype of <code>AbstractModel</code> can be passed to any function defined for <code>AbstractModel</code>, provided that the concrete type has the fields that the function expects to be available.</p><p>If a user wants to define a new subclass of models, say regression models, then the user could create a new <code>AbstractRegressionModel</code> type as a subtype of <code>AbstractModel</code>. Functions defined for <code>AbstractRegressionModel</code> would only apply to concrete subtypes of <code>AbstractRegressionModel</code>, but functions defined for <code>AbstractModel</code> will still work on these concrete subtypes.</p><h2 id="The-AbstractParameter-Type-1"><a class="docs-heading-anchor" href="#The-AbstractParameter-Type-1">The <code>AbstractParameter</code> Type</a><a class="docs-heading-anchor-permalink" href="#The-AbstractParameter-Type-1" title="Permalink"></a></h2><p>The <code>AbstractParameter</code> type implements our notion of a model parameter: a time-invariant, unobserved value that has significance in the model, e.g. for likelihood computation and estimation.</p><p>Though all parameters are time-invariant, they can have different features. Some parameters are scaled for use when solving the model<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> and constructing the model&#39;s measurement equations<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. You can also use broadcasting for elementary mathematical operations (e.g. multiplication, addition) on any concrete subtype of <code>AbstractParameter</code>.</p><p>During optimization, parameters may be transformed from model space to the real line via one of three different transformations: <code>Untransformed</code>, <code>SquareRoot</code>, and <code>Exponential</code>. These transformations are also defined as types, and require additional information for each parameter. Typically, we have two &quot;hyperparameters&quot; for these transformations, <code>a</code>, and <code>b</code>.</p><ul><li><code>Untransformed</code>: <code>a</code> and <code>b</code> do nothing</li><li><code>SquareRoot</code>: <code>a</code> and <code>b</code> specify the bounds the parameter takes, i.e. <span>$x\in (a, b)$</span></li><li><code>Exponential</code>: <code>a</code> and <code>b</code> are the parameters in the transformation <span>$a + exp(x - b)$</span></li></ul><p>In some models, steady state values might be relevant parameters. They are typically functions of other parameters, so they do not need to be estimated directly.</p><p>While parameters are &quot;time-invariant&quot;, we do allow regime switching. As an example, suppose that we have a linear regression with data from time periods <span>$t = 1,\dots, T$</span>, where <span>$T &gt; 4$</span>, and in <span>$t = 3$</span>, the intercept of the regression is assumed to change values because of a structural break in the time series. We can model the intercept as a parameter with regime-switching. The parameter has one value in periods <span>$t = 1, 2$</span> and a different value in periods <span>$t = 3,\dots, T$</span>. Currently, only regime-switching in the values of the parameter has been tested, but we have implemented regime switching in all the features. For example, you may want a different prior in each regime. See <a href="@ref">Regime-Switching Interface</a> for documentation on the interface for regime-switching parameters.</p><p>The various requirements on parameters are nicely addressed using a parameterized type hierarchy.</p><ul><li><code>AbstractParameter{T&lt;:Number}</code>: The common abstract supertype for all parameters.<ul><li><code>Parameter{T&lt;:Number, U&lt;:Transform}</code>: The abstract supertype for parameters that are directly estimated.<ul><li><code>UnscaledParameter{T&lt;:Number, U:&lt;Transform}</code>: Concrete type for parameters that do not need to be scaled for equilibrium conditions.</li><li><code>ScaledParameter{T&lt;:Number, U:&lt;Transform}</code>: Concrete type for parameters that are scaled for equilibrium conditions.</li></ul></li><li><code>SteadyStateParameter{T&lt;:Number}</code>: Concrete type for steady-state parameters.</li></ul></li></ul><p>All <code>Parameter</code>s have the fields defined in <code>UnscaledParameter</code>:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>UnscaledParameter</code>. Check Documenter&#39;s build log for details.</p></div></div><p><code>ScaledParameters</code> also have the following fields:</p><ul><li><code>scaledvalue::T</code>: Parameter value scaled for use in <code>eqcond.jl</code></li><li><code>scaling::Function</code>: Function used to scale parameter value for use in equilibrium conditions.</li></ul><p><em>Note:</em> Though not strictly necessary, defining a scaling with the parameter object allows for much a much cleaner definition of the equilibrium conditions.</p><p>Because the values of <code>SteadyStateParameter</code>s are directly computed as a function of <code>ScaledParameter</code>s and <code>UnscaledParameter</code>s, they only require 4 fields:</p><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.SteadyStateParameter" href="#ModelConstructors.SteadyStateParameter"><code>ModelConstructors.SteadyStateParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SteadyStateParameter{T} &lt;: AbstractParameter{T}</code></pre><p>Steady-state model parameter whose value depends upon the value of other (non-steady-state) <code>Parameter</code>s. <code>SteadyStateParameter</code>s must be constructed and added to an instance of a model object <code>m</code> after all other model <code>Parameter</code>s have been defined. Once added to <code>m</code>, <code>SteadyStateParameter</code>s are stored in <code>m.steady_state</code>. Their values are calculated and set by <code>steadystate!(m)</code>, rather than being estimated directly. <code>SteadyStateParameter</code>s do not require transformations from the model space to the real line or scalings for use in equilibrium conditions.</p><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code>: Parameter name. Should conform to the guidelines established in the DSGE Style Guide.</li><li><code>value::T</code>: The parameter&#39;s steady-state value.</li><li><code>description::String</code>: Short description of the parameter&#39;s economic significance.</li><li><code>tex_label::String</code>: String for printing parameter name to LaTeX.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L223-L243">source</a></section></article><h2 id="The-Observable-and-PseudoObservable-Types-1"><a class="docs-heading-anchor" href="#The-Observable-and-PseudoObservable-Types-1">The <code>Observable</code> and <code>PseudoObservable</code> Types</a><a class="docs-heading-anchor-permalink" href="#The-Observable-and-PseudoObservable-Types-1" title="Permalink"></a></h2><p>We similarly encapsulate information about observables and pseudo-observables (unobserved linear combinations of states, e.g. the output gap) into the <code>Observable</code> and <code>PseudoObservable</code> types. Each type has identifier fields <code>key</code>, <code>name</code>, and <code>longname</code>.</p><p>Most importantly, both <code>Observable</code>s and <code>PseudoObservable</code>s include the information needed for transformations to and from model units. For <code>Observable</code>s, these are the <code>input_series</code>, <code>fwd_transform</code>, and <code>rev_transform</code> fields. &quot;Forward transformations&quot; are applied to transform the raw input data series specified in <code>input_series</code> to model units. The model is estimated and forecasted in model units, and then we apply &quot;reverse transformations&quot; to get human-readable units before computing means and bands or plotting. Pseudo-observables are not observed, so they do not have <code>input_series</code> or <code>fwd_transform</code>s, but they may however have <code>rev_transform</code>s.</p><p>As an example, the <code>:obs_gdp</code> <code>Observable</code> uses as <code>input_series</code> aggregate nominal GDP in levels, the GDP price index, and population in levels, all from FRED.<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> These series are <code>fwd_transform</code>ed to get quarter-over-quarter log growth rates of per-capita real GDP, which are the <code>Observable</code>&#39;s model units. The reverse transformation then converts <code>:obs_gdp</code> into annualized quarter-over-quarter percent changes of <em>aggregate</em> real GDP.</p><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.Observable" href="#ModelConstructors.Observable"><code>ModelConstructors.Observable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Observable</code></pre><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code></li><li><code>input_series::Vector{Symbol}</code>: vector of mnemonics, each in the form <code>:MNEMONIC__SOURCE</code> (e.g. <code>:GDP__FRED</code>). This vector is parsed to determine source (e.g. per-capita consumption gets population and consumption).</li><li><code>fwd_transform::Function</code>: Extracts appropriate <code>input_series</code> from a DataFrame of levels, and transforms data to model units (for example, computes per-capita growth rates from levels).</li><li><code>rev_transform::Function</code>: Transforms a series from model units into observable units. May take kwargs.</li><li><code>name::String</code>: e.g. &quot;Real GDP growth&quot;</li><li><code>longname::String</code>: e.g. &quot;Real GDP growth per capita&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/observables.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.PseudoObservable" href="#ModelConstructors.PseudoObservable"><code>ModelConstructors.PseudoObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PseudoObservable</code></pre><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code></li><li><code>name::String</code>: e.g. &quot;Flexible Output Growth&quot;</li><li><code>longname::String</code>: e.g. &quot;Output that would prevail in a flexible-price economy&quot;</li><li><code>rev_transform::Function</code>: Transforms a series from model units into observable units. May take kwargs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/observables.jl#L38-L51">source</a></section></article><h2 id="Model-Settings-1"><a class="docs-heading-anchor" href="#Model-Settings-1">Model Settings</a><a class="docs-heading-anchor-permalink" href="#Model-Settings-1" title="Permalink"></a></h2><p>The <code>Setting</code> type implements computational settings that affect how the code runs without affecting the mathematical definition of the model. Depending on the model, these may include flags (e.g. whether or not to recompute the Hessian), parameterization for the Metropolis-Hastings algorithm (e.g. number of times to draw from the posterior distribution), and the vintage of data being used (<code>Setting</code> is a parametric type - a <code>Setting{T&lt;:Any}</code>, so Booleans, Numbers, and Strings can all be turned into <code>Setting</code>s). If settings exist for a model type, then they should be stored centrally in the <code>settings</code> dictionary within the model object.</p><p>Why implement a <code>Setting</code> type when we could put their values directly into the source code or dictionary? The most obvious answer is that the parametric type allows us to implement a single interface for all <code>Setting</code>s (Booleans, Strings, etc.), so that when we access a particular setting during the estimation and forecast steps, we don&#39;t have to think about the setting&#39;s type.</p><p><code>Setting</code>s play an important role in addition to providing useful abstraction. Estimating and forecasting the New York Fed DSGE model takes many hours of computation time and creates a lot of output files. It is useful to be able to compare model output from two different models whose settings differ slightly (for example, consider two identical models that use different vintages of data as input). A central feature of the <code>Setting</code> type is a mechanism that generates unique, meaningful filenames when code is executed with different settings. Specifically, when a setting takes on a non-default value, a user-defined setting code (along with the setting&#39;s value) are appended to all output files generated during execution.</p><p>The <code>Setting{T&lt;:Any}</code> type is defined as follows:</p><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.Setting" href="#ModelConstructors.Setting"><code>ModelConstructors.Setting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Setting{T}</code></pre><p>The <code>Setting</code> type is an interface for computational settings that affect how the code runs without affecting the mathematical definition of the model. It also provides support for non-conflicting file names for output of 2 models that differ only in the values of their computational settings.</p><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code>: Name of setting</li><li><code>value::T</code>: Value of setting</li><li><code>print::Bool</code>: Indicates whether to append this setting&#39;s code and value to output file names. If true, output file names will include a suffix of the form <code>_code1=val1_code2=val2</code> etc. where codes are listed in alphabetical order.</li><li><code>code::String</code>: string to print to output file suffixes when <code>print=true</code>.</li><li><code>description::String</code>: Short description of what the setting is used for.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/settings.jl#L1-L20">source</a></section></article><p>We provide two functions <code>default_settings!</code> and <code>default_test_settings!</code> to initialize settings that most models can have. The settings are</p><ul><li>save root</li><li>input data root</li><li>vintage of data to be used</li><li>dataset id</li></ul><p>To update the value of an existing function, the user has two options. First, the user may use the <code>&lt;=</code> syntax. However, for this to work properly, it is essential that the setting&#39;s <code>key</code> field be exactly the same as that of an existing entry in <code>m.settings</code>. Otherwise, an additional entry will be added to <code>m.settings</code> and the old setting will be the one accessed from other all routines. A potentially safer, though clunkier, option is to use the <a href="#ModelConstructors.update!-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1},BitArray{1}}} where S"><code>update!</code></a> method.</p><h2 id="Type-Interfaces-1"><a class="docs-heading-anchor" href="#Type-Interfaces-1">Type Interfaces</a><a class="docs-heading-anchor-permalink" href="#Type-Interfaces-1" title="Permalink"></a></h2><h3 id="Parameter-Interface-1"><a class="docs-heading-anchor" href="#Parameter-Interface-1"><code>Parameter</code> Interface</a><a class="docs-heading-anchor-permalink" href="#Parameter-Interface-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractArray{AbstractParameter{Float64},1}}" href="#Base.rand-Tuple{AbstractArray{AbstractParameter{Float64},1}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Distributions.rand(p::Vector{AbstractParameter{Float64}}; regime_switching::Bool = false,
    toggle::Bool = true)</code></pre><p>Generate a draw from the prior of each parameter in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1341-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Array{AbstractParameter{Float64},1},Int64}" href="#Base.rand-Tuple{Array{AbstractParameter{Float64},1},Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Distributions.rand(p::Vector{AbstractParameter{Float64}}, n::Int;
    regime_switching::Bool = false, toggle::Bool = true)</code></pre><p>Generate <code>n</code> draws from the priors of each parameter in <code>p</code>.This returns a matrix of size <code>(length(p),n)</code>, where each column is a sample. To sample from <code>p</code> when it has regime-switching, set <code>regime_switching =  true</code>. The <code>toggle</code> keyword is only relevant for regime-switching sampling. Please see <code>?ModelConstructors.rand_regime_switching</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1437-L1447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.differentiate_transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S" href="#ModelConstructors.differentiate_transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S"><code>ModelConstructors.differentiate_transform_to_model_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">differentiate_transform_to_model_space{S&lt;:Real,T&lt;:Number, U&lt;:Transform}(p::Parameter{S,T,U}, x::S)</code></pre><p>Differentiates the transform of <code>x</code> from the real line to lie between <code>p.valuebounds</code> The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):</p><ul><li>Untransformed: <code>x</code></li><li>SquareRoot:    <code>(a+b)/2 + (b-a)/2 * c * x/sqrt(1 + c^2 * x^2)</code></li><li>Exponential:   <code>a + exp(c*(x-b))</code></li></ul><p>Their gradients are therefore</p><ul><li>Untransformed: <code>1</code></li><li>SquareRoot:    <code>(b-a)/2 * c / (1 + c^2 * x^2)^(3/2)</code></li><li>Exponential:   <code>c * exp(c*(x-b))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L844-L862">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.differentiate_transform_to_real_line-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S" href="#ModelConstructors.differentiate_transform_to_real_line-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S"><code>ModelConstructors.differentiate_transform_to_real_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">differentiate_transform_to_real_line{S&lt;:Real,T&lt;:Number, U&lt;:Transform}(p::Parameter{S,T,U}, x::S)</code></pre><p>Differentiates the transform of <code>x</code> from the model space lying between <code>p.valuebounds</code> to the real line. The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):</p><ul><li>Untransformed: x</li><li>SquareRoot:   (1/c)*cx/sqrt(1 - cx^2), where cx =  2 * (x - (a+b)/2)/(b-a)</li><li>Exponential:   b + (1 / c) * log(x-a)</li></ul><p>Their gradients are therefore</p><ul><li>Untransformed: <code>1</code></li><li>SquareRoot:    <code>(1/c) * (1 / ( 1 - cx^2)^(-3/2)) * (2/(b-a))</code></li><li>Exponential:   <code>1 / (c * (x - a))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L980-L998">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.get_untransformed_values-Tuple{AbstractParameter}" href="#ModelConstructors.get_untransformed_values-Tuple{AbstractParameter}"><code>ModelConstructors.get_untransformed_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_untransformed_values(p::AbstractParameter)</code></pre><p>returns the untransformed values that are used in mathematical operations. The main use case is returning the <code>scaledvalue</code> if <code>p</code> is a <code>ScaledParameter</code> and <code>value</code> if it is an <code>UnscaledParameter</code>.</p><p>This function currently does not work with regime-switching parameters.</p><p>Additionally, note that unless <code>p.value</code> is a concrete subtype of <code>AbstractArray</code> or some other type such that <code>p.value</code> is just a reference, then it is advisable to avoid using <code>get_untransformed_values</code> when possible. The reason is that <code>p.value</code> creates an extra allocation when <code>p.value</code> is not a reference. For example, if <code>p = parameter(:a, 1.0)</code>, then <code>p.value</code> creates 1 allocation, hence <code>get_untransformed_values(p)</code> creates 1 allocation. This behavior means that while <code>p * p</code> creates 1 allocation, <code>get_untransformed_values(p) * get_untransformed_values(p)</code> creates 3 allocations. If <code>get_untransformd_values</code> is called many times, then these additional allocations can add some extra time to the computations. For example, <code>p.value * rand(1e7)</code> versus <code>p * rand(1e7)</code> can result in 10 additional microseconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1583-L1604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.moments-Tuple{Parameter}" href="#ModelConstructors.moments-Tuple{Parameter}"><code>ModelConstructors.moments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">moments(θ::Parameter)</code></pre><p>If θ&#39;s prior is a <code>RootInverseGamma</code>, τ and ν. Otherwise, returns the mean and standard deviation of the prior. If θ is fixed, returns <code>(θ.value, 0.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1461-L1468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.n_parameters_regime_switching-Tuple{Array{AbstractParameter{T},1} where T}" href="#ModelConstructors.n_parameters_regime_switching-Tuple{Array{AbstractParameter{T},1} where T}"><code>ModelConstructors.n_parameters_regime_switching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function n_parameters_regime_switching(p::ParameterVector)</code></pre><p>calculates the total number of parameters in <code>p</code> across all regimes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1564-L1570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{ScaledParameter{T,U},T}} where U&lt;:Transform where T&lt;:Number" href="#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{ScaledParameter{T,U},T}} where U&lt;:Transform where T&lt;:Number"><code>ModelConstructors.parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter(p::ScaledParameter{S,T,U}, newvalue::S) where {S&lt;:Real, T&lt;:Number,U&lt;:Transform}</code></pre><p>Returns a ScaledParameter with value field equal to <code>newvalue</code> and scaledvalue field equal to <code>p.scaling(newvalue)</code>. If <code>p</code> is a fixed parameter, it is returned unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L626-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{UnscaledParameter{T,U},T}} where U&lt;:Transform where T&lt;:Number" href="#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{UnscaledParameter{T,U},T}} where U&lt;:Transform where T&lt;:Number"><code>ModelConstructors.parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter(p::UnscaledParameter{S,T,U}, newvalue::S) where {S&lt;:Real,T&lt;:Number,U&lt;:Transform}</code></pre><p>Returns an UnscaledParameter with value field equal to <code>newvalue</code>. If <code>p</code> is a fixed parameter, it is returned unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L577-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{V}, Tuple{Symbol,Union{T, V}}, Tuple{Symbol,Union{T, V},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U,Union{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}, Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}}}}} where U&lt;:Transform where T&lt;:Real where V&lt;:(Array{T,1} where T)" href="#ModelConstructors.parameter-Union{Tuple{U}, Tuple{T}, Tuple{V}, Tuple{Symbol,Union{T, V}}, Tuple{Symbol,Union{T, V},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T}}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U}, Tuple{Symbol,Union{T, V},Tuple{T,T},Tuple{T,T},U,Union{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}, Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}}}}} where U&lt;:Transform where T&lt;:Real where V&lt;:(Array{T,1} where T)"><code>ModelConstructors.parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter{S,T,U&lt;:Transform}(key::Symbol, value::S, valuebounds = (value,value),
                          transform_parameterization = (value,value),
                          transform = Untransformed(), prior = NullablePrior();
                          fixed = true, scaling::Function = identity, description = &quot;&quot;,
                          tex_label::String = &quot;&quot;)</code></pre><p>By default, returns a fixed <code>UnscaledParameter</code> object with key <code>key</code> and value <code>value</code>. If <code>scaling</code> is given, a <code>ScaledParameter</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L377-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.parameters2namedtuple-Union{Tuple{AbstractArray{S,1}}, Tuple{S}} where S&lt;:AbstractParameter" href="#ModelConstructors.parameters2namedtuple-Union{Tuple{AbstractArray{S,1}}, Tuple{S}} where S&lt;:AbstractParameter"><code>ModelConstructors.parameters2namedtuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters2namedtuple(m)</code></pre><p>returns the parameters of <code>m</code> as a <code>NamedTuple</code>. The input <code>m</code> e acan be either an <code>AbstractVector{&lt;: AbstractParameter}</code> or an <code>AbstractModel</code>.</p><p>This function currently does not work with regime-switching parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1609-L1618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S" href="#ModelConstructors.transform_to_model_space-Union{Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s101&quot;,Untransformed} where var&quot;#s101&quot;&lt;:Number,S}} where S"><code>ModelConstructors.transform_to_model_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform_to_model_space{S&lt;:Real,T&lt;:Number, U&lt;:Transform}(p::Parameter{S,T,U}, x::S)</code></pre><p>Transforms <code>x</code> from the real line to lie between <code>p.valuebounds</code> without updating <code>p.value</code>. The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):</p><ul><li>Untransformed: <code>x</code></li><li>SquareRoot:    <code>(a+b)/2 + (b-a)/2 * c * x/sqrt(1 + c^2 * x^2)</code></li><li>Exponential:   <code>a + exp(c*(x-b))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L755-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.transform_to_real_line-Union{Tuple{ModelConstructors.ParameterAD{S,var&quot;#s100&quot;,Untransformed} where var&quot;#s100&quot;&lt;:Number}, Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s99&quot;,Untransformed} where var&quot;#s99&quot;&lt;:Number,S}} where S" href="#ModelConstructors.transform_to_real_line-Union{Tuple{ModelConstructors.ParameterAD{S,var&quot;#s100&quot;,Untransformed} where var&quot;#s100&quot;&lt;:Number}, Tuple{S}, Tuple{ModelConstructors.ParameterAD{S,var&quot;#s99&quot;,Untransformed} where var&quot;#s99&quot;&lt;:Number,S}} where S"><code>ModelConstructors.transform_to_real_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform_to_real_line(p::Parameter{S,T,U}, x::S = p.value) where {S&lt;:Real, T&lt;:Number, U&lt;:Transform}</code></pre><p>Transforms <code>p.value</code> from model space (between <code>p.valuebounds</code>) to the real line, without updating <code>p.value</code>. The transformations are defined as follows, where (a,b) = p.transform_parameterization, c a scalar (default=1), and x = p.value:</p><ul><li>Untransformed: x</li><li>SquareRoot:   (1/c)*cx/sqrt(1 - cx^2), where cx =  2 * (x - (a+b)/2)/(b-a)</li><li>Exponential:   b + (1 / c) * log(x-a)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L874-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.update!-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1},BitArray{1}}} where S" href="#ModelConstructors.update!-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1},BitArray{1}}} where S"><code>ModelConstructors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(pvec::ParameterVector, values::AbstractVector{S},
    indices::BitArray{1}; change_value_type::Bool = false) where S</code></pre><p>Updates a subset of parameters in <code>pvec</code> specified by indices. Assumes <code>values</code> is sorted in the same order as the parameters in <code>pvec</code>, ignoring parameters that are to be left unchanged.</p><p>However, <code>update!</code> will not overwrite fixed parameters, even if <code>indices</code> has a true in an index corresponding to a fixed parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pvec = ParameterVector{Float64}(undef, 3);
julia&gt; pvec[1] = parameter(:a, 1., (0., 3.), (0., 3.), fixed = false);
julia&gt; pvec[2] = parameter(:b, 1.);
julia&gt; pvec[3] = parameter(:c, 1., (0., 3.), (0., 3.), fixed = false);
julia&gt; values = [2., 2.];
julia&gt; update!(pvec, values, [true, false, true]);
julia&gt; map(x -&gt; x.value, pvec)
3-element Array{Float64,1}:
 2.0
 1.0
 2.0
</code></pre><pre><code class="language-julia-repl">julia&gt; pvec = ParameterVector{Float64}(undef, 3);
julia&gt; pvec[1] = parameter(:a, 1.);
julia&gt; pvec[2] = parameter(:b, 1.);
julia&gt; pvec[3] = parameter(:c, 1.);
julia&gt; values = [2., 2.];
julia&gt; update!(pvec, values, [true, false, true]);
julia&gt; map(x -&gt; x.value, pvec)
3-element Array{Float64,1}:
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1204-L1248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.update!-Union{Tuple{T}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{T,1}}} where T" href="#ModelConstructors.update!-Union{Tuple{T}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{T,1}}} where T"><code>ModelConstructors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(pvec::ParameterVector, values::AbstractVector{S}; change_value_type::Bool = false) where S</code></pre><p>Update all parameters in <code>pvec</code> that are not fixed with <code>values</code>. Length of <code>values</code> does not need equal length of <code>pvec</code> (as in the case of regime-switching parameters). Function optimized for speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1142-L1150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.update-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1}}} where S" href="#ModelConstructors.update-Union{Tuple{S}, Tuple{Array{AbstractParameter{T},1} where T,AbstractArray{S,1}}} where S"><code>ModelConstructors.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update(pvec::ParameterVector, values::Vector{S}) where S</code></pre><p>Returns a copy of <code>pvec</code> where non-fixed parameter values are updated to <code>values</code>. <code>pvec</code> remains unchanged. Length of <code>values</code> must equal length of <code>pvec</code>.</p><p>We define the non-mutating version like this because we need the type stability of map!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1272-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.rand_regime_switching-Tuple{AbstractArray{AbstractParameter{Float64},1}}" href="#ModelConstructors.rand_regime_switching-Tuple{AbstractArray{AbstractParameter{Float64},1}}"><code>ModelConstructors.rand_regime_switching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand_regime_switching(p::Vector{AbstractParameter{Float64}}; toggle::Bool = true)</code></pre><p>Generate a draw from the prior of each parameter in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/parameters.jl#L1372-L1378">source</a></section></article><h3 id="Regime-Switching-Interface-1"><a class="docs-heading-anchor" href="#Regime-Switching-Interface-1">Regime-Switching Interface</a><a class="docs-heading-anchor-permalink" href="#Regime-Switching-Interface-1" title="Permalink"></a></h3><p>To implement regime-switching, we add a field to <code>Parameter</code> types called <code>regimes::Dict{Symbol, OrderedDict{Int, Any}}</code>. The keys of the top level dictionary are the names of the other fields in a <code>Parameter</code> type, e.g. <code>:value</code>. Each key then points to an <code>OrderedDict</code>, whose keys are the numbers of different regimes and values are the corresponding values for each regime.</p><p>The field <code>regimes</code> functions as a &quot;storage&quot; of information. When a <code>Parameter</code> type interacts with another object in Julia, e.g. <code>p + 1.</code>, where <code>p</code> is a <code>Parameter</code>, what actually happens is <code>p.value + 1.</code>. Only the current fields of <code>p</code> will be used when interacting with other objects. To use a different value (or different fields) from another regime, the user needs to tell the parameter to switch regimes the <code>toggle_regime!</code> function (see below).</p><p>By default, the <code>regimes</code> field is empty (see the documentation of the <code>parameter</code> function in <a href="#Parameter-Interface-1"><code>Parameter</code> Interface</a>). To add values, either pass in the dictionary as a keyword to <code>parameter</code> or use <code>set_regime_val!</code>. Note that the latter function is not exported.</p><p><em>Note that regimes must be sorted in order</em> because we store the regimes as an <code>OrderedDict</code>, and <code>OrderedDict</code> objects are sorted by insertion order.</p><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.regime_fixed-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real" href="#ModelConstructors.regime_fixed-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real"><code>ModelConstructors.regime_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regime_fixed(p::Parameter{S}, i::Int) where S &lt;: Real
regime_fixed(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real</code></pre><p>returns whether <code>p</code> is fixed in regime <code>i</code> for the first method and whether true <code>p</code> is fixed in regime <code>d[model_regime]</code> for the second method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.regime_prior-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real" href="#ModelConstructors.regime_prior-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real"><code>ModelConstructors.regime_prior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regime_prior(p::Parameter{S}, i::Int) where S &lt;: Real
regime_prior(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real</code></pre><p>returns the prior of <code>p</code> in regime <code>i</code> for the first method and the prior of <code>p</code> in regime <code>d[model_regime]</code> for the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.regime_val-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real" href="#ModelConstructors.regime_val-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real"><code>ModelConstructors.regime_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regime_val(p::Parameter{S}, i::Int) where S &lt;: Real
regime_val(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real</code></pre><p>returns the value of <code>p</code> in regime <code>i</code> for the first method and the value of <code>p</code> in regime <code>d[model_regime</code> for the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.regime_valuebounds-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real" href="#ModelConstructors.regime_valuebounds-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real"><code>ModelConstructors.regime_valuebounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regime_valuebounds(p::Parameter{S}, i::Int) where S &lt;: Real
regime_valuebounds(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real</code></pre><p>returns the <code>valuebounds</code> of <code>p</code>  in regime <code>i</code> for the first method and the <code>valuebounds</code> of <code>p</code> in regime <code>d[model_regime]</code> for the second method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.set_regime_fixed!-Union{Tuple{S1}, Tuple{S}, Tuple{Parameter{S1,U} where U&lt;:Transform,Int64,S}} where S1&lt;:Real where S&lt;:Bool" href="#ModelConstructors.set_regime_fixed!-Union{Tuple{S1}, Tuple{S}, Tuple{Parameter{S1,U} where U&lt;:Transform,Int64,S}} where S1&lt;:Real where S&lt;:Bool"><code>ModelConstructors.set_regime_fixed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_regime_fixed!(p::Parameter{S}, i::Int, v::S; update_valuebounds::Interval = (NaN, NaN))</code></pre><p>sets whether <code>p</code> is fixed in regime <code>i</code> of <code>p</code>. Set update_valuebounds to true to set the valuebounds to match the fixed value.</p><p>The second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary <code>d</code> maps each &quot;model&quot; regime to a &quot;parameter&quot; regime. In this way, the second method specifies which &quot;parameter&quot; regime should be used at a given &quot;model&quot; regime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L149-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.set_regime_prior!-Union{Tuple{S}, Tuple{Parameter,Int64,S}} where S&lt;:Union{Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}}}" href="#ModelConstructors.set_regime_prior!-Union{Tuple{S}, Tuple{Parameter,Int64,S}} where S&lt;:Union{Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{0},Distributions.Continuous}}, Nullables.Nullable{Distributions.Distribution{Distributions.ArrayLikeVariate{1},Distributions.Continuous}}}"><code>ModelConstructors.set_regime_prior!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_regime_prior!(p::Parameter{S}, i::Int, v)
set_regime_prior!(p::Parameter{S}, model_regime::Int, v, d::AbstractDict{Int, Int})</code></pre><p>sets the prior in regime <code>i</code> of <code>p</code> to be <code>v</code>. The type of <code>v</code> can be a <code>NullablePriorUnivariate</code>, <code>NullablePriorMultivariate</code>, <code>ContinuousUnivariateDistribution</code>, or `ContinuousMultivariateDistribution&#39;.</p><p>The second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary <code>d</code> maps each &quot;model&quot; regime to a &quot;parameter&quot; regime. In this way, the second method specifies which &quot;parameter&quot; regime should be used at a given &quot;model&quot; regime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L80-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.set_regime_val!-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64,S}} where S&lt;:Real" href="#ModelConstructors.set_regime_val!-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64,S}} where S&lt;:Real"><code>ModelConstructors.set_regime_val!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> set_regime_val!(p::Parameter{S},
    i::Int, v::S; override_bounds::Bool = false) where S &lt;: Real
 set_regime_val!(p::Parameter{S},
    model_regime::Int, v::S, d::AbstractDict{Int, Int}; override_bounds::Bool = false) where S &lt;: Real</code></pre><p>sets the value in regime <code>i</code> of <code>p</code> to be <code>v</code>. By default, we enforce the bounds that are currently in <code>p</code>, but the bounds can be ignoerd by setting <code>override_bounds = true</code>.</p><p>The second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary <code>d</code> maps each &quot;model&quot; regime to a &quot;parameter&quot; regime. In this way, the second method specifies which &quot;parameter&quot; regime should be used at a given &quot;model&quot; regime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.set_regime_valuebounds!-Union{Tuple{S}, Tuple{Parameter,Int64,Tuple{S,S}}} where S&lt;:Real" href="#ModelConstructors.set_regime_valuebounds!-Union{Tuple{S}, Tuple{Parameter,Int64,Tuple{S,S}}} where S&lt;:Real"><code>ModelConstructors.set_regime_valuebounds!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_regime_valuebounds!(p::Parameter{S}, i::Int, v::S)</code></pre><p>sets valuebounds for <code>p</code> in regime <code>i</code> to <code>v</code>.</p><p>The second method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary <code>d</code> maps each &quot;model&quot; regime to a &quot;parameter&quot; regime. In this way, the second method specifies which &quot;parameter&quot; regime should be used at a given &quot;model&quot; regime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L221-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.toggle_regime!-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real" href="#ModelConstructors.toggle_regime!-Union{Tuple{S}, Tuple{Parameter{S,U} where U&lt;:Transform,Int64}} where S&lt;:Real"><code>ModelConstructors.toggle_regime!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toggle_regime!(p::Parameter{S}, i::Int) where S &lt;: Real
toggle_regime!(pvec::ParameterVector{S}, i::Int) where S &lt;: Real
toggle_regime!(p::Parameter{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real
toggle_regime!(pvec::ParameterVector{S}, model_regime::Int, d::AbstractDict{Symbol, &lt;: AbstractDict{Int, Int}}) where S &lt;: Real
toggle_regime!(pvec::ParameterVector{S}, model_regime::Int, d::AbstractDict{Int, Int}) where S &lt;: Real</code></pre><p>changes the fields of <code>p</code> to regime <code>i</code>.</p><p>For example, if</p><pre><code class="language-none">p.regimes[:value] = OrderedDict{Int, Any}(1 =&gt; 1, 2 =&gt; 3)</code></pre><p>then <code>toggle_regime!(p, 1)</code> will cause <code>p.value = 1</code> and <code>toggle_regime!(p, 2)</code> will cause <code>p.value = 3</code>.</p><p>The third method allows the user to pass a dictionary to permit the case where there may be differences between the regimes of a regime-switching model and the regimes for the parameters. For example, aside from regime-switching in parameters, the model may also include other forms of regime-switching. To allow estimation of regime-switching parameters in such a model, the dictionary <code>d</code> maps each &quot;model&quot; regime to a &quot;parameter&quot; regime. In this way, the second method specifies which &quot;parameter&quot; regime should be used at a given &quot;model&quot; regime.</p><p>The fourth method extends the third to a ParameterVector, with the possibility that each parameter may have different mappings to the model regimes. Each key of <code>d</code> corresponds to the key of a parameter, and each value of <code>d</code> is the mapping for model regimes to the parameter regimes of <code>p.key</code>. The fifth method is similar to the fourth but assumes any regime-switching parameter has the same mapping from model regimes to parameter regimes, hence the use of a common dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L269-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.get_values-Union{Tuple{Array{AbstractParameter{S},1}}, Tuple{S}} where S&lt;:Real" href="#ModelConstructors.get_values-Union{Tuple{Array{AbstractParameter{S},1}}, Tuple{S}} where S&lt;:Real"><code>ModelConstructors.get_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_values(pvec::ParameterVector{S}; regime_switching::Bool = true) where {S &lt;: Real}</code></pre><p>constructs a vector of the underlying values in a <code>ParameterVector</code>, including if there are regime-switching values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/regimes.jl#L349-L356">source</a></section></article><h3 id="Setting-Interface-1"><a class="docs-heading-anchor" href="#Setting-Interface-1"><code>Setting</code> Interface</a><a class="docs-heading-anchor-permalink" href="#Setting-Interface-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;=-Tuple{AbstractModel,Setting}" href="#Base.:&lt;=-Tuple{AbstractModel,Setting}"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(&lt;=)(m::AbstractModel, s::Setting)</code></pre><p>Syntax for adding a setting to a model/overwriting a setting via <code>m &lt;= Setting(...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/settings.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.get_setting-Tuple{AbstractModel,Symbol}" href="#ModelConstructors.get_setting-Tuple{AbstractModel,Symbol}"><code>ModelConstructors.get_setting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_setting(m::AbstractModel, setting::Symbol)</code></pre><p>Returns the value of the setting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/settings.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelConstructors.update!-Tuple{Setting,Setting}" href="#ModelConstructors.update!-Tuple{Setting,Setting}"><code>ModelConstructors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(a::Setting, b::Setting)</code></pre><p>Update <code>a</code> with the fields of <code>b</code> if:</p><ul><li>The <code>key</code> field is updated if <code>a.key == b.key</code></li><li>The <code>print</code> boolean and <code>code</code> string are overwritten if <code>a.print</code> is false and <code>b.print</code> is true, or <code>a.print</code> is true, <code>b.print</code> is false, and b.code is non-empty.</li><li>The <code>description</code> field is updated if <code>b.description</code> is nonempty</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/a5c9540b0902d25b3f726e856543c35ae254fe29/src/settings.jl#L70-L82">source</a></section></article><pre><code class="language-none">rng::MersenneTwister
testing::Bool
observable_mappings::Dict{Symbol, Observable}
pseudo_observable_mappings::Dict{Symbol, PseudoObservable}</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>By solving the model, we mean a mapping from parameters to        some objects of interest. In a state space model,        solving the model is a mapping from parameters        to a state transition function. By constructing</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>In the context of a state space model,         a measurement equation is mapping from states to observable data.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>In <a href="https://github.com/FRBNY-DSGE/DSGE.jl">DSGE.jl</a>, we implement a          <code>load_data</code> function that parses <code>input_series</code> to retrieve data          from FRED. To take full advantage of the <code>Observable</code> type, users may          want to write their own <code>load_data</code> function. For example, it may          be convenient to write a <code>load_data</code> function that parses <code>input_series</code>          to select column(s) from saved CSV files and combines them into          a single data frame.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example_model/">« Creating Models</a><a class="docs-footer-nextpage" href="../regime_switching/">Regime-Switching Parameters »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 July 2021 20:10">Thursday 1 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
