<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forecasting · ModelConstructors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ModelConstructors.jl logo"/></a><h1>ModelConstructors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../model_design/">Model Design</a></li><li><a class="toctext" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="toctext" href="../advanced_usage/">Advanced Usage</a></li><li><a class="toctext" href="../input_data/">Input Data</a></li><li><a class="toctext" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="toctext" href="../implementation_details/">Implementation Details</a></li><li><a class="toctext" href="../solving/">Solving the Model</a></li><li><a class="toctext" href="../estimation/">Estimation</a></li><li class="current"><a class="toctext" href>Forecasting</a><ul class="internal"><li><a class="toctext" href="#Procedure-1">Procedure</a></li><li><a class="toctext" href="#Forecast-Outputs-1">Forecast Outputs</a></li><li><a class="toctext" href="#Preparing-Forecast-Inputs-1">Preparing Forecast Inputs</a></li><li><a class="toctext" href="#Computing-Forecast-Outputs-1">Computing Forecast Outputs</a></li><li><a class="toctext" href="#Saving-Forecast-Outputs-1">Saving Forecast Outputs</a></li></ul></li><li><a class="toctext" href="../means_bands/">Computing Means and Bands</a></li><li><a class="toctext" href="../altpolicy/">Alternative Policies</a></li><li><a class="toctext" href="../scenarios/">Alternative Scenarios</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../algorithms/">Algorithms</a></li><li><a class="toctext" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="toctext" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="toctext" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Forecasting</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/master/docs/src/forecast.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Forecasting</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="forecast-step-1" href="#forecast-step-1">Forecasting</a></h1><h2><a class="nav-anchor" id="Procedure-1" href="#Procedure-1">Procedure</a></h2><p>In the forecast step, we compute smoothed histories, forecast, compute shock decompositions, and compute impulse response functions (IRFs) for states, observables, shocks, and pseudo-observables. To run a forecast on one combination of input parameter type (e.g. modal parameters or full-distribution) and conditional type, call <code>forecast_one</code>.</p><p><strong>Main Steps:</strong></p><ul><li><p><em>Prepare forecast inputs:</em> Add required output types, load data, and load draws of parameter vectors saved from the estimation step.</p></li><li><p><em>Compute forecast outputs:</em> Carry out desired combination of smoothing, forecasting, computing shock decompositions, and computing IRFs. See <a href="#Forecast-Outputs-1">Forecast Outputs</a> for a list of possible forecast outputs.</p></li><li><p><em>Save forecast outputs:</em> Save each forecast output as an array to its own file, along with some metadata.</p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.forecast_one" href="#DSGE.forecast_one"><code>DSGE.forecast_one</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">forecast_one(m, input_type, cond_type, output_vars; df = DataFrame(),
    subset_inds = 1:0, forecast_string = &quot;&quot;, verbose = :low)</code></pre><p>Compute and save <code>output_vars</code> for input draws given by <code>input_type</code> and conditional data case given by <code>cond_type</code>.</p><p><strong>Inputs</strong></p><ul><li><p><code>m::AbstractModel</code>: model object</p></li><li><p><code>input_type::Symbol</code>: one of:</p></li></ul><pre><code class="language-none">  - `:mode`: forecast using the modal parameters only
  - `:mean`: forecast using the mean parameters only
  - `:init`: forecast using the initial parameter values only
  - `:full`: forecast using all parameters (full distribution)
  - `:subset`: forecast using a well-defined user-specified subset of draws</code></pre><ul><li><code>cond_type::Symbol</code>: one of:</li></ul><pre><code class="language-none">  - `:none`: no conditional data
  - `:semi`: use &quot;semiconditional data&quot; - average of quarter-to-date
    observations for high frequency series
  - `:full`: use &quot;conditional data&quot; - semiconditional plus nowcasts for
    desired observables</code></pre><ul><li><code>output_vars::Vector{Symbol}</code>: vector of desired output variables. See <code>?forecast_one_draw</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>df::DataFrame</code>: Historical data. If <code>cond_type in [:semi, :full]</code>, then the  final row of <code>df</code> should be the period containing conditional data. If not  provided, will be loaded using <code>load_data</code> with the appropriate <code>cond_type</code></li><li><code>subset_inds::AbstractRange{Int64}</code>: indices specifying the draws we want to use. If a more sophisticated selection criterion is desired, the user is responsible for determining the indices corresponding to that criterion. If <code>input_type</code> is not <code>subset</code>, <code>subset_inds</code> will be ignored</li><li><code>forecast_string::String</code>: short string identifying the subset to be appended to the output filenames. If <code>input_type = :subset</code> and <code>forecast_string</code> is empty, an error is thrown.</li><li><code>verbose::Symbol</code>: desired frequency of function progress messages printed to standard out. One of <code>:none</code>, <code>:low</code>, or <code>:high</code>.</li></ul><p><strong>Outputs</strong></p><p>None. Output is saved to files returned by <code>get_forecast_output_files(m, input_type, cond_type, output_vars)</code>.</p></div></div></section><p>For example, to do an unconditional forecast of states and observables using the modal parameters, call:</p><pre><code class="language-julia">m = AnSchorfheide()
forecast_one(m, :mode, :none, [:forecaststates, forecastobs])</code></pre><p><strong>Full-Distribution Forecasts:</strong></p><p>Full-distribution forecasts are computed in blocks. The size of each block defaults to 5000 draws (before thinning by <code>get_setting(m, :forecast_jstep)</code>), but can be set using the <code>:forecast_block_size</code> <code>Setting</code>. For each block, draws are read in on the originator process, then computation proceeds in parallel using <code>pmap</code>. When all draws in the block are finished, the forecast outputs are reassembled on the originator process and appended to the HDF5 dataset in their respective output files.</p><p>To fully take advantage of the parallelization, the user is responsible for adding processes before calling <code>forecast_one</code>, either by calling <code>addprocs</code> or using one of the functions defined in <a href="https://github.com/JuliaParallel/ClusterManagers.jl">ClusterManagers.jl</a>. For example, to run a full-distribution unconditional forecast using 10 processes:</p><pre><code class="language-julia">my_procs = addprocs(10)
@everywhere using DSGE

m = AnSchorfheide()
forecast_one(m, :full, :none, [:forecaststates, forecastobs])

rmprocs(my_procs)</code></pre><p>Notice that it is necessary to load DSGE on all processes using <code>@everywhere using DSGE</code> before calling <code>forecast_one</code>.</p><p>By default, full-distribution forecasts start from the first block. However, if you want to start the forecast from a later block, you can also do so. For example:</p><pre><code class="language-julia">m &lt;= Setting(:forecast_start_block, 2,
    &quot;Block at which to resume forecasting (possibly null)&quot;)</code></pre><h2><a class="nav-anchor" id="Forecast-Outputs-1" href="#Forecast-Outputs-1">Forecast Outputs</a></h2><p>A forecast output (i.e. an <code>output_var</code>) is a combination of what we call a &quot;product&quot; and a &quot;class&quot;. The possible classes are states (<code>:states</code>), observables (<code>:obs</code>), pseudo-observables (<code>:pseudo</code>), and standardized (<code>:stdshocks</code>) and unstandardized shocks (<code>:shocks</code>). The possible forecast products are:</p><ul><li><p>Smoothed histories (<code>:hist</code>): use the smoother specified by <code>forecast_smoother(m)</code> to get smoothed histories of each class.</p></li><li><p>Forecasts (<code>:forecast</code>): iterate the state space forward from the last filtered state, either using a specified set of shock innovations or by drawing these from a distribution. Forecasts in which we enforce the zero lower bound are denoted as <code>:bddforecast</code>.</p></li><li><p>Shock decompositions (<code>:shockdec</code>): starting from an initial state of zero, iterate the state space forward from the first historical period up through the last forecast horizon. Use the smoothed historical shocks for one shock at a time during the historical periods and no shocks during the forecast periods.</p></li><li><p>Deterministic trends (<code>:dettrend</code>): iterate the state space forward from first historical state up through the last forecast horizon without any shocks.</p></li><li><p>Trends (<code>:trend</code>): for each class, just the constant term in that class&#39;s equation, i.e. the <code>CCC</code> vector from the transition equation for states, the <code>DD</code> vector from the measurement equation for observables, and the <code>DD_pseudo</code> vector from the pseuodo-measurement equation for pseudo-observables.</p></li><li><p>IRFs (<code>:irf</code>): see <a href="https://en.wikipedia.org/wiki/Impulse_response">Impulse response</a>. Our IRFs are in response to a shock of size -1 standard deviation.</p></li></ul><p>An <code>output_var</code> is then just a <code>Symbol</code> with a product and class concatenated, e.g. <code>:histstates</code> for smoothed historical states.</p><p>It is not necessary to compute all forecast outputs in one call to <code>forecast_one</code>. Which steps are run depends on which <code>output_vars</code> are passed in.</p><h2><a class="nav-anchor" id="Preparing-Forecast-Inputs-1" href="#Preparing-Forecast-Inputs-1">Preparing Forecast Inputs</a></h2><p><strong>Adding Required <code>output_var</code>s:</strong></p><p>This step is done by <code>add_requisite_output_vars</code>:</p><ul><li>If <code>:forecast&lt;class&gt;</code> is in <code>output_vars</code>, then <code>:bddforecast&lt;class&gt;</code> is also added. Hence we always forecast both with and without enforcing the ZLB.</li><li>If <code>:shockdec&lt;class&gt;</code> is in <code>output_vars</code>, then <code>:dettrend&lt;class&gt;</code> and <code>:trend&lt;class&gt;</code> are also added. This is because to plot shock decompositions, we also need the trend and the deterministic trend.</li></ul><p><strong>Loading Data:</strong></p><p>This is done the usual way, using <code>load_data</code> with the appropriate <code>cond_type</code>.</p><p><strong>Loading Draws:</strong></p><p>By default, the draws are loaded from the file whose path is given by <code>get_forecast_input_file</code>. However, you can override the default input file for a given input type by adding entries to the <code>Dict{Symbol, ASCIIString}</code> returned from <code>forecast_input_file_overrides(m)</code>. For example:</p><pre><code class="language-julia">overrides = forecast_input_file_overrides(m)
overrides[:mode] = &quot;path/to/input/file.h5&quot;</code></pre><p>Note that <code>load_draws</code> expects an HDF5 dataset called either <code>params</code> (for <code>input_type in [:mode, :mean]</code>) or <code>mhparams</code> (for <code>input_type in [:full, :subset]</code>).</p><h2><a class="nav-anchor" id="Computing-Forecast-Outputs-1" href="#Computing-Forecast-Outputs-1">Computing Forecast Outputs</a></h2><p><strong>Smoothing:</strong></p><p>Smoothing is necessary if either:</p><ul><li>You explicitly want the smoothed histories, or</li><li>You want to compute shock decompositions or deterministic trends, which use the smoothed historical shocks</li></ul><p>It is not necessary to keep track of these cases, however - <code>forecast_one</code> will deduce from the specified <code>output_vars</code> whether or not it is necessary to filter and smooth in order to produce your <code>output_vars</code>.</p><p><strong>Forecasting:</strong></p><p>Forecasting begins from the last filtered historical state, which is obtained from the Kalman filter. <code>forecast</code> accepts a keyword argument <code>enforce_zlb</code>, which indicates whether to enforce the zero lower bound. If <code>enforce_zlb = true</code>, then if in a given period, the forecasted interest rate goes below <code>forecast_zlb_value(m)</code>, we solve for the interest rate shock necessary to push it up to the ZLB. A forecast in which the ZLB is enforced corresponds to the product <code>:bddforecast</code>.</p><p><strong>Shock Decompositions, Deterministic Trends, and Trends:</strong></p><p>Since shock decompositions have an additional dimension (e.g. <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code> for a single draw of state shock decompositions, compared to <code>nstates</code> x <code>nperiods</code> for a single draw of forecasted states), we usually wish to truncate some periods before returning. This behavior is governed by the <code>Settings</code> <code>:shockdec_starttdate</code> and <code>:shockdec_enddate</code>, which are of type <code>Nullable{Date}</code>.</p><p>Deterministic trends are also saved only for <code>date_shockdec_start(m)</code> and <code>date_shockdec_end(m)</code>. Trends are not time-dependent.</p><p><strong>Impulse Response Functions:</strong></p><p>Like shock decompositions, IRFs have three dimensions (e.g. <code>nstates</code> x <code>nperiods</code> x <code>nshocks</code>) for each draw.</p><h2><a class="nav-anchor" id="Saving-Forecast-Outputs-1" href="#Saving-Forecast-Outputs-1">Saving Forecast Outputs</a></h2><p>Forecast outputs are saved in the location specified by <code>get_forecast_output_files(m)</code>, which is typically a subdirectory of <code>saveroot(m)</code>. Each <code>output_var</code> is saved in its own JLD file, which contains the following datasets:</p><ul><li><p><code>arr::Array</code>: actual array of forecast outputs. For trends, this array is of size <code>ndraws</code> x <code>nvars</code>. For histories, forecasts, and deterministic trends, it is <code>ndraws</code> x <code>nvars</code> x <code>nperiods</code>. For shock decompositions and IRFs, it is <code>ndraws</code> x <code>nvars</code> x <code>nperiods</code> x <code>nshocks</code>. (In all of these, <code>nvars</code> refers to the number of variables of the output class.)</p></li><li><p><code>date_indices::Dict{Date, Int}</code>: maps <code>Date</code>s to their indices along the <code>nperiods</code> dimension of <code>arr</code>. Not saved for IRFs.</p></li><li><p><code>&lt;class&gt;_names::Dict{Symbol, Int}</code>: maps names of variables of the output class (e.g. <code>:OutputGap</code>) into their indices along the <code>nvars</code> dimension of <code>arr</code>.</p></li><li><p><code>&lt;class&gt;_revtransforms::Dict{Symbol, Symbol}</code>: maps names of variables to the names of the reverse transforms (from model units into plotting units) associated with those variables. For example, <code>pseudoobservable_revtransforms[:π_t] = :quartertoannual</code>.</p></li><li><p><code>shock_names::Dict{Symbol, Int}</code>: for shock decompositions and IRFs only, maps names of shocks into their indices along the <code>nshocks</code> dimension of <code>arr</code>.</p></li></ul><p>Some helpful functions for getting file names, as well as reading and writing forecast outputs, include:</p><ul><li><code>get_forecast_input_file</code></li><li><code>get_forecast_filename</code></li><li><code>get_forecast_output_files</code></li><li><code>write_forecast_outputs</code></li><li><code>write_forecast_block</code></li><li><code>write_forecast_metadata</code></li><li><code>read_forecast_metadata</code></li><li><code>read_forecast_output</code></li></ul><footer><hr/><a class="previous" href="../estimation/"><span class="direction">Previous</span><span class="title">Estimation</span></a><a class="next" href="../means_bands/"><span class="direction">Next</span><span class="title">Computing Means and Bands</span></a></footer></article></body></html>
