<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input Data · ModelConstructors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ModelConstructors.jl logo"/></a><h1>ModelConstructors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../model_design/">Model Design</a></li><li><a class="toctext" href="../running_existing_model/">Running An Existing Model</a></li><li><a class="toctext" href="../advanced_usage/">Advanced Usage</a></li><li class="current"><a class="toctext" href>Input Data</a><ul class="internal"><li><a class="toctext" href="#Setup-1">Setup</a></li><li><a class="toctext" href="#Loading-data-1">Loading data</a></li><li><a class="toctext" href="#Non-FRED-data-sources-1">Non-FRED data sources</a></li><li><a class="toctext" href="#Incorporate-population-forecasts-1">Incorporate population forecasts</a></li><li><a class="toctext" href="#Dataset-creation-implementation-details-1">Dataset creation implementation details</a></li><li><a class="toctext" href="#Common-pitfalls-1">Common pitfalls</a></li><li><a class="toctext" href="#Update-sample-input-data-1">Update sample input data</a></li><li><a class="toctext" href="#Data-Transforms-and-Utilities-1">Data Transforms and Utilities</a></li></ul></li><li><a class="toctext" href="../frbny_data/">FRBNY Model Input Data</a></li><li><a class="toctext" href="../implementation_details/">Implementation Details</a></li><li><a class="toctext" href="../solving/">Solving the Model</a></li><li><a class="toctext" href="../estimation/">Estimation</a></li><li><a class="toctext" href="../forecast/">Forecasting</a></li><li><a class="toctext" href="../means_bands/">Computing Means and Bands</a></li><li><a class="toctext" href="../altpolicy/">Alternative Policies</a></li><li><a class="toctext" href="../scenarios/">Alternative Scenarios</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../algorithms/">Algorithms</a></li><li><a class="toctext" href="../contributing/">Contributing to DSGE.jl</a></li><li><a class="toctext" href="../MatlabToJuliaTransition/">MATLAB to Julia Transition: Estimation</a></li><li><a class="toctext" href="../julia_forecasting/">MATLAB to Julia Transition: Forecast</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Input Data</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/ModelConstructors.jl/blob/master/docs/src/input_data.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Input Data</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="input-data-step-1" href="#input-data-step-1">Input Data</a></h1><p>Given all of the hard work put into specifying the model, one should be able to maintain the input data painlessly. To that extent, <em>DSGE.jl</em> provides facilities to download appropriate vintages of data series from FRED (Federal Reserve Economic Data).</p><p>Note that a sample input dataset for use with model <code>m990</code> is provided; see <a href="../frbny_data/#frbny-data-1">New York Fed Model 990 Data</a> for more details. To update this sample dataset for use with model <code>m990</code>, see <a href="#Update-sample-input-data-1">Update sample input data</a>.</p><h2><a class="nav-anchor" id="Setup-1" href="#Setup-1">Setup</a></h2><p>To take advantage of the ability to automatically download data series from FRED via the <em>FredData.jl</em> package, set up your FRED API access by following the directions <a href="https://github.com/micahjsmith/FredData.jl/blob/master/README.md">here</a>.</p><h2><a class="nav-anchor" id="Loading-data-1" href="#Loading-data-1">Loading data</a></h2><p>At the most basic, loading data looks like this:</p><pre><code class="language-julia">m = Model990()
df = load_data(m)</code></pre><p>By default, <code>load_data</code> will look on the disk first to see if an appropriate vintage of data is already present. If data on disk are not present, or if the data are invalid for any reason, a fresh vintage will be downloaded from FRED and merged with the other data sources specified. See <a href="#DSGE.load_data-Tuple{AbstractModel}"><code>load_data</code></a> for more details.</p><p>The resulting DataFrame <code>df</code> contains all the required data series for this model, fully transformed. The first row is given by the Setting <code>date_presample_start</code> and the last row is given by <code>date_mainsample_end</code>. The first <code>n_presample_periods</code> rows of <code>df</code> are the presample.</p><p>Driver functions including <code>estimate</code> accept this <code>df</code> as an argument and convert it into a <code>Matrix</code> suitable for computations using <code>df_to_matrix</code>, which sorts the data, ensures the full sample is present, discards the date column, and sorts the observable columns according to the <code>observables</code> field of the model object.</p><h2><a class="nav-anchor" id="Non-FRED-data-sources-1" href="#Non-FRED-data-sources-1">Non-FRED data sources</a></h2><p>Some data series may not be available from FRED or one may simply wish to use a different data source, for whatever reason. The data sources and series are specified in the <code>data_series</code> field of the model object. For each data source that is <em>not</em> <code>:fred</code>, a well-formed CSV of the form <code>&lt;source&gt;_&lt;yymmdd&gt;.csv</code> is expected in the directory indicated by <code>inpath(m, &quot;raw&quot;)</code>.  For example, the following might be the contents of a data source for two series <code>:series1</code> and <code>:series2</code>:</p><pre><code class="language-none">date,series1,series2
1959-06-30,1.0,NaN
1959-09-30,1.1,0.5
# etc.</code></pre><p>Note that quarters are represented by the date of the <em>last</em> day of the quarter and missing values are specified by <code>NaN</code>.</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Let&#39;s consider an example dataset comprised of 10 macro series sourced from FRED and one survey-based series sourced from, say, the Philadelphia Fed&#39;s <a href="http://www.philadelphiafed.org/research-and-data/real-time-center/survey-of-professional-forecasters/historical-data/inflation-forecasts">Survey of Professional Forecasters</a> via Haver Analytics:</p><pre><code class="language-none">julia&gt; m.data_series
Dict{Symbol,Array{Symbol,1}} with 2 entries:
 :spf   =&gt; [:ASACX10]
 :fred  =&gt; [:GDP, :PCE, ...] # etc</code></pre><p>If the data vintage specified for the model is <code>151127</code> (Nov. 27, 2015), then the following files are expected in <code>inpath(m, &quot;raw&quot;)</code>:</p><pre><code class="language-none">spf_151127.csv
fred_151127.csv</code></pre><p>The FRED series will be downloaded and the <code>fred_151127.csv</code> file will be automatically generated, but the <code>spf_151127.csv</code> file must be manually compiled as shown above:</p><pre><code class="language-none">date,ASACX10
1991-12-31,4.0
# etc.</code></pre><p>Now, suppose that we set the data vintage to <code>151222</code>, to incorporate the BEA&#39;s third estimate of GDP. The <code>fred_151222.csv</code> file will be downloaded, but there are no updates to the SPF dataset during this period. Regardless, the file <code>spf_151222.csv</code> must be present to match the data vintage. The solution in this case is to manually copy and rename the older SPF dataset. Although this is not an elegant approach, it is consistent with the concept of a vintage as the data available at a certain point in time –- in this example, it just so happens that the SPF data available on Nov. 27 and Dec. 22 are the same.</p><h2><a class="nav-anchor" id="Incorporate-population-forecasts-1" href="#Incorporate-population-forecasts-1">Incorporate population forecasts</a></h2><p>Many variables enter the model in per-capita terms. To that extent, we use data on population levels to adjust aggregate variables into per-capita variables. Furthermore, we apply the <a href="https://en.wikipedia.org/wiki/Hodrick%E2%80%93Prescott_filter">Hodrick-Prescott filter</a> (&quot;H-P filter&quot;) to the population levels to smooth cyclical components.</p><p>The user will ultimately want to produce forecasts of key variables such as GDP and then represent these forecasts in standard terms. That is, one wants to report GDP forecasts in aggregate terms, which is standard, rather than per-capita terms. To do this, we either extrapolate from the last periods of population growth in the data, or use external population forecasts.</p><p>Note that if external population forecasts are provided, non-forecast procedures, such as model estimation, are also affected because the H-P filter smoothes back from the latest observation.</p><p>To incorporate population forecasts,</p><ol><li>Set the model setting <code>use_population_forecast</code> to <code>true</code>.</li><li>Provide a file <code>population_forecast_&lt;yymmdd&gt;.csv</code> to <code>inpath(m, &quot;raw&quot;)</code>. Population forecasts should be in levels, and represent the same series as given by the <code>population_mnemonic</code> setting (defaults to <code>:CNP16OV</code>, or &quot;Civilian Noninstitutional Population, Thousands&quot;). If your population forecast is in growth rates, convert it to levels yourself. The first row of data should correspond to the last period of the main sample, such that growth rates can be computed. As many additional rows of forecasts as desired can be provided.</li></ol><p>The file should look like this:</p><pre><code class="language-none">date,POPULATION
2015-12-31,250000
2016-03-31,251000
# etc.</code></pre><h2><a class="nav-anchor" id="Dataset-creation-implementation-details-1" href="#Dataset-creation-implementation-details-1">Dataset creation implementation details</a></h2><p>Let&#39;s quickly walk through the steps <em>DSGE.jl</em> takes to create a suitable dataset.</p><p>First, a user provides a detailed specification of the data series and transformations used for their model.</p><ul><li><p>the user specifies <code>m.observables</code>; the keys of this dictionary name   the series to be used in estimating the model.</p></li><li><p>the user specifies <code>m.observable_mappings</code>; the keys of this dictionary name observed variables, and the values correspond to the observable object, which contains information about the forward and reverse transforms as well as the input data series from which the observable is constructed.</p></li><li><p>For a given observable, an input series, e.g.   <code>m.observable_mappings[:obs_gdp].input_series</code>, is an array of mnemonics to be   accessed from the data source listed after the mnemonic (separated by the double   underscore).Note that these mnemonics do not correspond to observables one-to-one,   but rather are usually series in <em>levels</em> that will be further transformed.</p></li><li><p>There are also both forward and reverse transforms for a given observable,   e.g. <code>m.observable_mappings[:obs_gdp].fwd_transform</code> and   <code>m.observable_mappings[:obs_gdp].rev_transform</code>. The forward transform operates on a   single argument, <code>levels</code>, which is a DataFrame of the data in levels returned by the   function <code>load_data_levels</code>. The reverse transform operates on a forward transformed   series (which is in model units) transforming it into human-readable units, such   as one quarter percent changes or per-capita adjustments. Both transforms return a   DataArray for a single series. These functions could do nothing, or they could   perform a more complex transformation. See   <a href="#Data-Transforms-and-Utilities-1">Data Transforms and Utilities</a> for more information about series-specific   transformations.</p></li><li><p>the user adjusts data-related settings, such as <code>data_vintage</code>, <code>data_id</code>,   <code>dataroot</code>, <code>date_presample_start</code>, <code>date_zlb_start</code>, <code>date_forecast_start</code>,   and <code>use_population_forecast</code>.</p></li></ul><p>Second, <em>DSGE.jl</em> attempts to construct the dataset given this setup through a call to <code>load_data</code>. See <a href="#DSGE.load_data-Tuple{AbstractModel}"><code>load_data</code></a> for more details.</p><ul><li>Intermediate data in levels are loaded. See <a href="#DSGE.load_data_levels-Tuple{AbstractModel}"><code>load_data_levels</code></a> for more details.</li><li>Transformations are applied to the data in levels. See <a href="#DSGE.transform_data-Tuple{AbstractModel,DataFrames.DataFrame}"><code>transform_data</code></a> for more details.</li><li>The data are saved to disk. See <a href="#DSGE.save_data-Tuple{AbstractModel,DataFrames.DataFrame}"><code>save_data</code></a> for more details.</li></ul><h2><a class="nav-anchor" id="Common-pitfalls-1" href="#Common-pitfalls-1">Common pitfalls</a></h2><p>Given the complexity of the data download, you may find that the dataset generated by <code>load_data</code> is not exactly as you expect. Here are some common pitfalls to look out for:</p><ul><li>Ensure that the <code>data_vintage</code> model setting is as you expect. (Try checking   <code>data_vintage(m)</code>.)</li><li>Ensure that the <code>data_id</code> model setting is correct for the given model.</li><li>Ensure that the <code>date_forecast_start</code> model setting is as you expect, and that is not   logically incompatible with <code>data_vintage</code>.</li><li>Ensure that the <code>data_series</code> field of the model object is set as expected.</li><li>Double check the transformations specified in the <code>data_transforms</code> field of the model   object.</li><li>Ensure that the keys of the <code>observables</code> and <code>data_transforms</code> fields of the model object   match.</li><li>Check the input files for <a href="#Non-FRED-data-sources-1">Non-FRED data sources</a>. They should be   in the directory indicated by <code>inpath(m, &quot;raw&quot;)</code>, be named appropriately given the   vintage of data expected, and be formatted appropriately. One may have to copy and   rename files of non-FRED data sources to match the specified vintage, even if the   contents of the files would be identical.</li><li>Look for any immediate issues in the final dataset saved   (<code>data_dsid=&lt;xx&gt;_vint=&lt;yymmdd&gt;.csv</code>). If a data series in this file is all   <code>NaN</code> values, then likely a non-FRED data source was not provided correctly.</li><li>Ensure that the column names of the data CSV match the keys of the <code>observables</code> field of   the model object.</li><li>You may receive a warning that an input data file &quot;does not contain the entire date range   specified&quot;. This means that observations are not provided for some periods in which the   model requires data. This is perfectly okay if your data series starts after   <code>date_presample_start</code>.</li></ul><p>If you experience any problems using <em>FredData.jl</em>, ensure your API key is provided correctly and that there are no issues with your firewall, etc. Any issues with <em>FredData.jl</em> proper should be reported on that project&#39;s page.</p><h2><a class="nav-anchor" id="Update-sample-input-data-1" href="#Update-sample-input-data-1">Update sample input data</a></h2><p>A sample dataset is provided for the 2015 Nov 27 vintage. To update this dataset:</p><p><strong>Step 1</strong>. See <a href="#Setup-1">Setup</a> to setup automatic data pulls using <em>FredData.jl</em>.</p><p><strong>Step 2</strong>. Specify the exact data vintage desired:</p><pre><code class="language-julia">julia&gt;  m &lt;= Setting(:data_vintage, &quot;yymmdd&quot;)</code></pre><p><strong>Step 3</strong>. Create data files for the non-FRED data sources (specified in    <code>m.data_series</code>). For model <code>m990</code>, the required data files include    <code>spf_&lt;yymmdd&gt;.csv</code> (with column <code>ASACX10</code>), <code>longrate_&lt;yymmdd&gt;.csv</code> (with    column <code>FYCCZA</code>), and <code>fernald_&lt;yymmdd&gt;.csv</code> (with columns <code>TFPJQ</code> and    <code>TFPKQ</code>). To include data on expected interest rates, the file    <code>ois_&lt;yymmdd&gt;.csv</code> is also required. To include data on population forecasts,    the file <code>population_forecst_&lt;yymmdd&gt;.csv</code> is also required (see    <a href="#Incorporate-population-forecasts-1">Incorporate population forecasts</a>. See    <a href="../frbny_data/#frbny-data-1">New York Fed Model Input Data</a> for details on the series    used and links to data sources.</p><p><strong>Step 4</strong>. Run <code>load_data(m)</code>; series from FRED will be downloaded and merged with the series from    non-FRED data sources that you have already created. See <a href="#Common-pitfalls-1">Common pitfalls</a> for some potential issues.</p><h2><a class="nav-anchor" id="Data-Transforms-and-Utilities-1" href="#Data-Transforms-and-Utilities-1">Data Transforms and Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.df_to_matrix-Tuple{AbstractModel,DataFrames.DataFrame}" href="#DSGE.df_to_matrix-Tuple{AbstractModel,DataFrames.DataFrame}"><code>DSGE.df_to_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">df_to_matrix(m, df; cond_type = :none, in_sample = true)</code></pre><p>Return <code>df</code>, converted to matrix of floats, and discard date column. Also ensure that rows are sorted by date and columns by <code>m.observables</code>, with the option to specify whether or not the out of sample rows are discarded. The output of this function is suitable for direct use in <code>estimate</code>, <code>posterior</code>, etc.</p><p><strong>Keyword Arguments:</strong></p><ul><li><code>include_presample::Bool</code>: indicates whether or not there are presample periods.</li><li><code>in_sample::Bool</code>: indicates whether or not to discard rows that are out of sample. Set this flag to false in</li></ul><p>the case that you are calling filter_shocks! in the scenarios codebase.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.load_cond_data_levels-Tuple{AbstractModel}" href="#DSGE.load_cond_data_levels-Tuple{AbstractModel}"><code>DSGE.load_cond_data_levels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">load_cond_data_levels(m::AbstractModel; verbose::Symbol=:low)</code></pre><p>Check on disk in <code>inpath(m, &quot;cond&quot;)</code> for a conditional dataset (in levels) of the correct vintage and load it.</p><p>The following series are also loaded from <code>inpath(m, &quot;raw&quot;)</code> and either appended or merged into the conditional data:</p><ul><li>The last period of (unconditional) data in levels (<code>data_levels_&lt;yymmdd&gt;.csv</code>), used to calculate growth rates</li><li>The first period of forecasted population (<code>population_forecast_&lt;yymmdd&gt;.csv</code>), used for per-capita calculations</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.load_data-Tuple{AbstractModel}" href="#DSGE.load_data-Tuple{AbstractModel}"><code>DSGE.load_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">load_data(m::AbstractModel; try_disk::Bool = true, verbose::Symbol = :low)</code></pre><p>Create a DataFrame with all data series for this model, fully transformed.</p><p>First, check the disk to see if a valid dataset is already stored in <code>inpath(m, &quot;data&quot;)</code>. A dataset is valid if every series in <code>m.observable_mappings</code> is present and the entire sample is contained (from <code>date_presample_start</code> to <code>date_mainsample_end</code>. If no valid dataset is already stored, the dataset will be recreated. This check can be eliminated by passing <code>try_disk=false</code>.</p><p>If the dataset is to be recreated, in a preliminary stage, intermediate data series as specified in <code>m.observable_mappings</code> are loaded in levels using <code>load_data_levels</code>. See <code>?load_data_levels</code> for more details.</p><p>Then, the series in levels are transformed as specified in <code>m.observable_mappings</code>. See <code>?transform_data</code> for more details.</p><p>If <code>m.testing</code> is false, then the resulting DataFrame is saved to disk as <code>data_&lt;yymmdd&gt;.csv</code>. The data are then returned to the caller.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.load_data_levels-Tuple{AbstractModel}" href="#DSGE.load_data_levels-Tuple{AbstractModel}"><code>DSGE.load_data_levels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">load_data_levels(m::AbstractModel; verbose::Symbol=:low)</code></pre><p>Load data in levels by appealing to the data sources specified for the model. Data from FRED is loaded first, by default; then, merge other custom data sources.</p><p>Check on disk in <code>inpath(m, &quot;data&quot;)</code> datasets, of the correct vintage, corresponding to the ones required by the entries in <code>m.observable_mappings</code>. Load the appropriate data series (specified in <code>m.observable_mappings[key].input_series</code>) for each data source.</p><p>To accomodate growth rates and other similar transformations, more rows of data may be downloaded than otherwise specified by the date model settings. (By the end of the process, these rows will have been dropped.)</p><p>Data from FRED (i.e. the <code>:fred</code> data source) are treated separately. These are downloaded using <code>load_fred_data</code>. See <code>?load_fred_data</code> for more details.</p><p>Data from non-FRED data sources are read from disk, verified, and merged.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.parse_data_series-Tuple{AbstractModel}" href="#DSGE.parse_data_series-Tuple{AbstractModel}"><code>DSGE.parse_data_series</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parse_data_series(m::AbstractModel)</code></pre><p>Parse <code>m.observable_mappings</code> for the data sources and mnemonics to read in.</p><p>Returns a <code>Dict{Symbol, Vector{Symbol}}</code> mapping sources =&gt; mnemonics found in that data file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.save_data-Tuple{AbstractModel,DataFrames.DataFrame}" href="#DSGE.save_data-Tuple{AbstractModel,DataFrames.DataFrame}"><code>DSGE.save_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">save_data(m::AbstractModel, df::DataFrame; cond_type::Symbol = :none)</code></pre><p>Save <code>df</code> to disk as CSV. File is located in <code>inpath(m, &quot;data&quot;)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.load_fred_data-Tuple{AbstractModel}" href="#DSGE.load_fred_data-Tuple{AbstractModel}"><code>DSGE.load_fred_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">load_fred_data(m::AbstractModel; start_date=&quot;1959-03-31&quot;, end_date=prev_quarter())</code></pre><p>Checks in <code>inpath(m, raw)</code> for a FRED dataset corresponding to <code>data_vintage(m)</code>. If a FRED vintage exists on disk, any required FRED series that is contained therein will be imported. All missing series will be downloaded directly from FRED using the <em>FredData</em> package. The full dataset is written to the appropriate data vintage file and returned.</p><p><strong>Arguments</strong></p><ul><li><code>m::AbstractModel</code>: the model object</li><li><code>start_date</code>: starting date.</li><li><code>end_date</code>: ending date.</li></ul><p><strong>Notes</strong></p><p>The FRED API reports observations according to the quarter-start date. <code>load_fred_data</code> returns data indexed by quarter-end date for compatibility with other datasets.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.transform_data-Tuple{AbstractModel,DataFrames.DataFrame}" href="#DSGE.transform_data-Tuple{AbstractModel,DataFrames.DataFrame}"><code>DSGE.transform_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">transform_data(m::AbstractModel, levels::DataFrame; cond_type::Symbol = :none,
    verbose::Symbol = :low)</code></pre><p>Transform data loaded in levels and order columns appropriately for the DSGE model. Returns DataFrame of transformed data.</p><p>The DataFrame <code>levels</code> is output from <code>load_data_levels</code>. The series in levels are transformed as specified in <code>m.observable_mappings</code>.</p><ul><li>To prepare for per-capita transformations, population data are filtered using <code>hpfilter</code>. The series in <code>levels</code> to use as the population series is given by the <code>population_mnemonic</code> setting. If <code>use_population_forecast(m)</code>, a population forecast is appended to the recorded population levels before the filtering. Both filtered and unfiltered population levels and growth rates are added to the <code>levels</code> data frame.</li><li>The transformations are applied for each series using the <code>levels</code> DataFrame as input.</li></ul><p>Conditional data (identified by <code>cond_type in [:semi, :full]</code>) are handled slightly differently: If <code>use_population_forecast(m)</code>, we drop the first period of the population forecast because we treat the first forecast period <code>date_forecast_start(m)</code> as if it were data. We also only apply transformations for the observables given in <code>cond_full_names(m)</code> or <code>cond_semi_names(m)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.annualtoquarter-Tuple{Any}" href="#DSGE.annualtoquarter-Tuple{Any}"><code>DSGE.annualtoquarter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>annualtoquarter(v)</code></p><p>Convert from annual to quarter frequency... by dividing by 4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.difflog-Tuple{Array{T,1} where T}" href="#DSGE.difflog-Tuple{Array{T,1} where T}"><code>DSGE.difflog</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">difflog(x::AbstractVector)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.difflog-Tuple{Array}" href="#DSGE.difflog-Tuple{Array}"><code>DSGE.difflog</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">difflog(x::Array{AbstractFloat})</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.hpfilter-Tuple{AbstractArray{T,1} where T,Real}" href="#DSGE.hpfilter-Tuple{AbstractArray{T,1} where T,Real}"><code>DSGE.hpfilter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">yt, yf = hpfilter(y, λ)</code></pre><p>Applies the Hodrick-Prescott filter (&quot;H-P filter&quot;). The smoothing parameter <code>λ</code> is applied to the columns of <code>y</code>, returning the trend component <code>yt</code> and the cyclical component <code>yf</code>. For quarterly data, one can use λ=1600.</p><p>Consecutive missing values at the beginning or end of the time series are excluded from the filtering. If there are missing values within the series, the filtered values are all missing.</p><p>See also:</p><pre><code class="language-none">Hodrick, Robert; Prescott, Edward C. (1997). &quot;Postwar U.S. Business Cycles: An Empirical
Investigation&quot;. Journal of Money, Credit, and Banking 29 (1): 1–16.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct-Tuple{AbstractArray}" href="#DSGE.loggrowthtopct-Tuple{AbstractArray}"><code>DSGE.loggrowthtopct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct(y)</code></pre><p>Transform from annualized quarter-over-quarter log growth rates to annualized quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used in Model 510, which has the core PCE inflation observable in annualized log growth rates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_4q_approx" href="#DSGE.loggrowthtopct_4q_approx"><code>DSGE.loggrowthtopct_4q_approx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_4q_approx(y, data = fill(NaN, 3))</code></pre><p>Transform from log growth rates to <em>approximate</em> 4-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_annualized-Tuple{AbstractArray}" href="#DSGE.loggrowthtopct_annualized-Tuple{AbstractArray}"><code>DSGE.loggrowthtopct_annualized</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_annualized(y)</code></pre><p>Transform from log growth rates to annualized quarter-over-quarter percent change.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_annualized_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.loggrowthtopct_annualized_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.loggrowthtopct_annualized_percapita</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_annualized_percapita(y, pop_growth)</code></pre><p>Transform from log per-capita growth rates to annualized aggregate (not per-capita) quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used for output, consumption, investment and GDP deflator (inflation).</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized percent change from quarter-over-quarter log growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.loggrowthtopct_percapita-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.loggrowthtopct_percapita</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_percapita(y, pop_growth)</code></pre><p>Transform from annualized quarter-over-quarter log per-capita growth rates to annualized quarter-over-quarter aggregate percent change.</p><p><strong>Note</strong></p><p>This should only be used in Model 510, which has the output growth observable in annualized log per-capita growth rates.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized percent change from annualized log growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_4q_approx" href="#DSGE.logleveltopct_4q_approx"><code>DSGE.logleveltopct_4q_approx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_4q_approx(y, data = fill(NaN, 4))</code></pre><p>Transform from log levels to <em>approximate</em> 4-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_annualized" href="#DSGE.logleveltopct_annualized"><code>DSGE.logleveltopct_annualized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_annualized(y, y0 = NaN)</code></pre><p>Transform from log levels to annualized quarter-over-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized quarter-over-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>y0</code>: the last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_annualized_approx" href="#DSGE.logleveltopct_annualized_approx"><code>DSGE.logleveltopct_annualized_approx</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_annualized_approx(y, y0 = NaN)</code></pre><p>Transform from log levels to <em>approximate</em> annualized quarter-over-quarter percent change.</p><p><strong>This method should only be used to transform scenarios forecasts, which are in   deviations from baseline.</strong></p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized quarter-over-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>y0</code>: the last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_annualized_percapita" href="#DSGE.logleveltopct_annualized_percapita"><code>DSGE.logleveltopct_annualized_percapita</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_annualized_percapita(y, pop_growth, y0 = NaN)</code></pre><p>Transform from per-capita log levels to annualized aggregate (not per-capita) quarter-over-quarter percent change.</p><p><strong>Note</strong></p><p>This is usually applied to labor supply (hours worked per hour), and probably shouldn&#39;t be used for any other observables.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to annualized aggregate quarter-over-quarter percent change from per-capita log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>y0</code>: The last data point in the history (of state or observable) corresponding to the <code>y</code> variable. This is required to compute a percent change for the first period.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.nominal_to_real-Tuple{Symbol,DataFrames.DataFrame}" href="#DSGE.nominal_to_real-Tuple{Symbol,DataFrames.DataFrame}"><code>DSGE.nominal_to_real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>nominal_to_real(col, df; deflator_mnemonic = :GDPDEF)</code></p><p>Converts nominal to real values using the specified deflator.</p><p><strong>Arguments</strong></p><ul><li><code>col</code>: Symbol indicating which column of <code>df</code> to transform</li><li><code>df</code>: DataFrame containining series for proper population measure and <code>col</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>deflator_mnemonic</code>: indicates which deflator to use to calculate real values. Default value is the FRED GDP Deflator mnemonic.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.oneqtrpctchange-Tuple{AbstractArray{T,1} where T}" href="#DSGE.oneqtrpctchange-Tuple{AbstractArray{T,1} where T}"><code>DSGE.oneqtrpctchange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">oneqtrpctchange(y)</code></pre><p>Calculates the quarter-to-quarter percentage change of a series.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.percapita-Tuple{AbstractModel,Symbol,DataFrames.DataFrame}" href="#DSGE.percapita-Tuple{AbstractModel,Symbol,DataFrames.DataFrame}"><code>DSGE.percapita</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">percapita(m, col, df)
percapita(col, df, population_mnemonic)</code></pre><p>Converts data column <code>col</code> of DataFrame <code>df</code> to a per-capita value.</p><p>The first method checks <code>hpfilter_population(m)</code>. If true, then it divides by the filtered population series. Otherwise it divides by the result of <code>parse_population_mnemonic(m)[1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>col</code>: <code>Symbol</code> indicating which column of data to transform</li><li><code>df</code>: <code>DataFrame</code> containining series for proper population measure and <code>col</code></li><li><code>population_mnemonic</code>: a mnemonic found in <code>df</code> for some population measure</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.quartertoannual-Tuple{Any}" href="#DSGE.quartertoannual-Tuple{Any}"><code>DSGE.quartertoannual</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>quartertoannual(v)</code></p><p>Convert from quarter to annual frequency... by multiplying by 4.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.quartertoannualpercent-Tuple{Any}" href="#DSGE.quartertoannualpercent-Tuple{Any}"><code>DSGE.quartertoannualpercent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>quartertoannualpercent(v)</code></p><p>Convert from quarter to annual frequency in percent... by multiplying by 400.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_data_filename-Tuple{AbstractModel,Symbol}" href="#DSGE.get_data_filename-Tuple{AbstractModel,Symbol}"><code>DSGE.get_data_filename</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_data_filename(m, cond_type)</code></pre><p>Returns the data file for <code>m</code>, which depends on <code>data_vintage(m)</code>, and if <code>cond_type in [:semi, :full]</code>, also on <code>cond_vintage(m)</code> and <code>cond_id(m)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.iterate_quarters-Tuple{Dates.Date,Int64}" href="#DSGE.iterate_quarters-Tuple{Dates.Date,Int64}"><code>DSGE.iterate_quarters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">iterate_quarters(start::Date, quarters::Int)</code></pre><p>Returns the date corresponding to <code>start</code> + <code>quarters</code> quarters.</p><p><strong>Inputs</strong></p><ul><li><code>start</code>: starting date</li><li><code>quarters</code>: number of quarters to iterate forward or backward</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.quartertodate-Tuple{String}" href="#DSGE.quartertodate-Tuple{String}"><code>DSGE.quartertodate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>quartertodate(string::String)</code></p><p>Convert <code>string</code> in the form &quot;YYqX&quot;, &quot;YYYYqX&quot;, or &quot;YYYY-qX&quot; to a Date of the end of the indicated quarter. &quot;X&quot; is in <code>{1,2,3,4}</code> and the case of &quot;q&quot; is ignored.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.subtract_quarters-Tuple{Dates.Date,Dates.Date}" href="#DSGE.subtract_quarters-Tuple{Dates.Date,Dates.Date}"><code>DSGE.subtract_quarters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>subtract_quarters(t1::Date, t0::Date)</code></p><p>Compute the number of quarters between t1 and t0, including t0 and excluding t1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.data_to_df-Union{Tuple{T}, Tuple{AbstractModel,Array{T,2},Date}} where T&lt;:AbstractFloat" href="#DSGE.data_to_df-Union{Tuple{T}, Tuple{AbstractModel,Array{T,2},Date}} where T&lt;:AbstractFloat"><code>DSGE.data_to_df</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">data_to_df(m, data, start_date)</code></pre><p>Create a <code>DataFrame</code> out of the matrix <code>data</code>, including a <code>:date</code> column beginning in <code>start_date</code>.  Variable names and indices are obtained from <code>m.observables</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.has_saved_data-Tuple{AbstractModel}" href="#DSGE.has_saved_data-Tuple{AbstractModel}"><code>DSGE.has_saved_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">has_saved_data(m::AbstractModel; cond_type::Symbol = :none)</code></pre><p>Determine if there is a saved dataset on disk for the required vintage and conditional type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.isvalid_data-Tuple{AbstractModel,DataFrames.DataFrame}" href="#DSGE.isvalid_data-Tuple{AbstractModel,DataFrames.DataFrame}"><code>DSGE.isvalid_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isvalid_data(m::AbstractModel, df::DataFrame; cond_type::Symbol = :none)</code></pre><p>Return if dataset is valid for this model, ensuring that all observables are contained and that all quarters between the beginning of the presample and the end of the mainsample are contained. Also checks to make sure that expected interest rate data is available if <code>n_anticipated_shocks(m) &gt; 0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.read_data-Tuple{AbstractModel}" href="#DSGE.read_data-Tuple{AbstractModel}"><code>DSGE.read_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">read_data(m::AbstractModel; cond_type::Symbol = :none)</code></pre><p>Read CSV from disk as DataFrame. File is located in <code>inpath(m, &quot;data&quot;)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.read_population_data-Tuple{AbstractModel}" href="#DSGE.read_population_data-Tuple{AbstractModel}"><code>DSGE.read_population_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">read_population_data(m; verbose = :low)

read_population_data(filename; verbose = :low)</code></pre><p>Read in population data stored in levels, either from <code>inpath(m, &quot;raw&quot;, &quot;population_data_levels_[vint].csv&quot;</code>) or <code>filename</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.read_population_forecast-Tuple{AbstractModel}" href="#DSGE.read_population_forecast-Tuple{AbstractModel}"><code>DSGE.read_population_forecast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">read_population_forecast(m; verbose = :low)

read_population_forecast(filename, population_mnemonic, last_recorded_date; verbose = :low)</code></pre><p>Read in population forecast in levels, either from <code>inpath(m, &quot;raw&quot;, &quot;population_forecast_[vint].csv&quot;)</code> or <code>filename</code>. If that file does not exist, return an empty <code>DataFrame</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.transform_population_data-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Symbol}" href="#DSGE.transform_population_data-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Symbol}"><code>DSGE.transform_population_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">transform_population_data(population_data, population_forecast,
    population_mnemonic; verbose = :low)</code></pre><p>Load, HP-filter, and compute growth rates from population data in levels. Optionally do the same for forecasts.</p><p><strong>Inputs</strong></p><ul><li><code>population_data</code>: pre-loaded DataFrame of historical population data containing the columns <code>:date</code> and <code>population_mnemonic</code>. Assumes this is sorted by date.</li><li><code>population_forecast</code>: pre-loaded <code>DataFrame</code> of population forecast containing the columns <code>:date</code> and <code>population_mnemonic</code></li><li><code>population_mnemonic</code>: column name for population series in <code>population_data</code> and <code>population_forecast</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>verbose</code>: one of <code>:none</code>, <code>:low</code>, or <code>:high</code></li><li><code>use_hpfilter</code>: whether to HP filter population data and forecast. See <code>Output</code> below.</li><li><code>pad_forecast_start::Bool</code>: Whether you want to re-size</li></ul><p>the population<em>forecast such that the first index is one quarter ahead of the last index of population</em>data. Only set to false if you have manually constructed population_forecast to artificially start a quarter earlier, so as to avoid having an unnecessary missing first entry.</p><p><strong>Output</strong></p><p>Two dictionaries containing the following keys:</p><ul><li><p><code>population_data_out</code>:</p><ul><li><code>:filtered_population_recorded</code>: HP-filtered historical population series (levels)</li><li><code>:dlfiltered_population_recorded</code>: HP-filtered historical population series (growth rates)</li><li><code>:dlpopulation_recorded</code>: Non-filtered historical population series (growth rates)</li></ul></li><li><p><code>population_forecast_out</code>:</p><ul><li><code>:filtered_population_forecast</code>: HP-filtered population forecast series (levels)</li><li><code>:dlfiltered_population_forecast</code>: HP-filtered population forecast series (growth rates)</li><li><code>:dlpopulation_forecast</code>: Non-filtered historical population series (growth rates)</li></ul></li></ul><p>If <code>population_forecast_file</code> is not provided, the r&quot;<em>forecast&quot; fields will be empty. If <code>use_hpfilter = false</code>, then the r&quot;</em>filtered*&quot; fields will be empty.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_irf_transform-Tuple{Function}" href="#DSGE.get_irf_transform-Tuple{Function}"><code>DSGE.get_irf_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_irf_transform(transform::Function)</code></pre><p>Returns the IRF-specific transformation, which doesn&#39;t add back population growth (since IRFs are given in deviations).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_nopop_transform-Tuple{Function}" href="#DSGE.get_nopop_transform-Tuple{Function}"><code>DSGE.get_nopop_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_nopop_transform(transform::Function)</code></pre><p>Returns the corresponding transformation which doesn&#39;t add back population growth. Used for shock decompositions, deterministic trends, and IRFs, which are given in deviations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_scenario_transform-Tuple{Function}" href="#DSGE.get_scenario_transform-Tuple{Function}"><code>DSGE.get_scenario_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_scenario_transform(transform::Function)</code></pre><p>Given a transformation used for usual forecasting, return the transformation used for <em>scenarios</em>, which are forecasted in deviations from baseline.</p><p>The 1Q deviation from baseline should really be calculated by 1Q transforming the forecasts (in levels) under the baseline (call this <code>y_b</code>) and alternative scenario (<code>y_s</code>), then subtracting baseline from alternative scenario (since most of our 1Q transformations are nonlinear). Let <code>y_d = y_s - y_b</code>. Then, for example, the most correct <code>loggrowthtopct_annualized</code> transformation is:</p><pre><code class="language-none">y_b_1q = 100*(exp(y_b/100)^4 - 1)
y_s_1q = 100*(exp(y_s/100)^4 - 1)
y_d_1q = y_b_1q - y_s_1q</code></pre><p>Instead, we approximate this by transforming the deviation directly:</p><pre><code class="language-none">y_d_1q ≈ 4*(y_b - y_s)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_transform4q-Tuple{Function}" href="#DSGE.get_transform4q-Tuple{Function}"><code>DSGE.get_transform4q</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_transform4q(transform::Function)</code></pre><p>Returns the 4-quarter transformation associated with the annualizing transformation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.lag-Tuple{AbstractArray,Int64}" href="#DSGE.lag-Tuple{AbstractArray,Int64}"><code>DSGE.lag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">series_lag_n = lag(series, n)</code></pre><p>Returns a particular data series lagged by n periods</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_4q" href="#DSGE.loggrowthtopct_4q"><code>DSGE.loggrowthtopct_4q</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_4q(y, data = fill(NaN, 3))</code></pre><p>Transform from log growth rates to 4-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.loggrowthtopct_4q_percapita" href="#DSGE.loggrowthtopct_4q_percapita"><code>DSGE.loggrowthtopct_4q_percapita</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loggrowthtopct_4q_percapita(y, pop_growth, data = fill(NaN, 3))</code></pre><p>Transform from log per-capita growth rates to aggregate 4-quarter percent change.</p><p><strong>Note</strong></p><p>This should only be used for output, consumption, investment, and GDP deflator (inflation).</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to aggregate 4-quarter percent change from log per-capita growth rates. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_4q" href="#DSGE.logleveltopct_4q"><code>DSGE.logleveltopct_4q</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_4q(y, data = fill(NaN, 4))</code></pre><p>Transform from log levels to 4-quarter percent change.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter percent change from log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.logleveltopct_4q_percapita" href="#DSGE.logleveltopct_4q_percapita"><code>DSGE.logleveltopct_4q_percapita</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logleveltopct_4q_percapita(y, pop_growth, data = fill(NaN, 4))</code></pre><p>Transform from per-capita log levels to 4-quarter aggregate percent change.</p><p><strong>Note</strong></p><p>This is usually applied to labor supply (hours worked), and probably shouldn&#39;t be used for any other observables.</p><p><strong>Inputs</strong></p><ul><li><p><code>y</code>: the data we wish to transform to 4-quarter aggregate percent change from per-capita log levels. <code>y</code> is either a vector of length <code>nperiods</code> or an <code>ndraws x</code>nperiods` matrix.</p></li><li><p><code>pop_growth::Vector</code>: the length <code>nperiods</code> vector of log population growth rates.</p></li><li><p><code>data</code>: if <code>y = [y_t, y_{t+1}, ..., y_{t+nperiods-1}]</code>, then <code>data = [y_{t-4}, y_{t-3}, y_{t-2}, y_{t-1}]</code>. This is necessary to compute 4-quarter percent changes for the first three periods.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.prepend_data-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#DSGE.prepend_data-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>DSGE.prepend_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">prepend_data(y, data)</code></pre><p>Prepends data necessary for running 4q transformations.</p><p><strong>Inputs:</strong></p><ul><li><code>y</code>: <code>ndraws x t</code> array representing a timeseries for variable <code>y</code></li><li><code>data</code>: vector representing a timeseries to prepend to <code>y</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.datetoquarter-Tuple{Dates.Date}" href="#DSGE.datetoquarter-Tuple{Dates.Date}"><code>DSGE.datetoquarter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>datetoquarter(date::Date)</code></p><p>Convert <code>string</code> in the form &quot;YYqX&quot;, &quot;YYYYqX&quot;, or &quot;YYYY-qX&quot; to a Date of the end of the indicated quarter. &quot;X&quot; is in <code>{1,2,3,4}</code> and the case of &quot;q&quot; is ignored.</p><p>Return an integer from the set <code>{1,2,3,4}</code>, corresponding to one of the quarters in a year given a Date object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.format_dates!-Tuple{Symbol,DataFrames.DataFrame}" href="#DSGE.format_dates!-Tuple{Symbol,DataFrames.DataFrame}"><code>DSGE.format_dates!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>format_dates!(col, df)</code></p><p>Change column <code>col</code> of dates in <code>df</code> from String to Date, and map any dates given in the interior of a quarter to the last day of the quarter.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_quarter_ends-Tuple{Dates.Date,Dates.Date}" href="#DSGE.get_quarter_ends-Tuple{Dates.Date,Dates.Date}"><code>DSGE.get_quarter_ends</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>get_quarter_ends(start_date::Date,end_date::Date)</code></p><p>Returns an Array of quarter end dates between <code>start_date</code> and <code>end_date</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.missing2nan-Tuple{Array}" href="#DSGE.missing2nan-Tuple{Array}"><code>DSGE.missing2nan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">missing2nan(a::Array)</code></pre><p>Convert all elements of Union{X, Missing.Missing} or Missing.Missing to type Float64.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.missing_cond_vars!-Tuple{AbstractModel,DataFrames.DataFrame}" href="#DSGE.missing_cond_vars!-Tuple{AbstractModel,DataFrames.DataFrame}"><code>DSGE.missing_cond_vars!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">missing_cond_vars!(m, df; cond_type = :none)</code></pre><p>Make conditional period variables not in <code>cond_semi_names(m)</code> or <code>cond_full_names(m)</code> missing if necessary.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.na2nan!-Tuple{Array}" href="#DSGE.na2nan!-Tuple{Array}"><code>DSGE.na2nan!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">na2nan!(df::Array)</code></pre><p>Convert all NAs in an Array to NaNs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.na2nan!-Tuple{DataFrames.DataFrame}" href="#DSGE.na2nan!-Tuple{DataFrames.DataFrame}"><code>DSGE.na2nan!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">na2nan!(df::DataFrame)</code></pre><p>Convert all NAs in a DataFrame to NaNs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.next_quarter" href="#DSGE.next_quarter"><code>DSGE.next_quarter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>next_quarter(q::TimeType = now())</code></p><p>Returns Date identifying last day of the next quarter</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.prev_quarter" href="#DSGE.prev_quarter"><code>DSGE.prev_quarter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>prev_quarter(q::TimeType = now())</code></p><p>Returns Date identifying last day of the previous quarter</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.reconcile_column_names-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}" href="#DSGE.reconcile_column_names-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}"><code>DSGE.reconcile_column_names</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reconcile_column_names(a::DataFrame, b::DataFrame)</code></pre><p>adds columns of missings to a and b so that both have the same set of column names.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.vinttodate-Tuple{String}" href="#DSGE.vinttodate-Tuple{String}"><code>DSGE.vinttodate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function vinttodate(vint)</code></pre><p>Return the string given by data_vintage(m), which is in the format YYYYMMDD, to a Date object.</p></div></div></section><footer><hr/><a class="previous" href="../advanced_usage/"><span class="direction">Previous</span><span class="title">Advanced Usage</span></a><a class="next" href="../frbny_data/"><span class="direction">Next</span><span class="title">FRBNY Model Input Data</span></a></footer></article></body></html>
